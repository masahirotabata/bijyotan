<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>美女単語（ユーザー）</title>
　<meta name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">



  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 10px;
      background: rgb(249, 249, 249);
    }

    h1, h3 {
      text-align: center;
      color: rgb(233, 30, 99);
    }

    #username, #plan {
      display: block;
      text-align: center;
      margin: 10px 0;
      font-size: 1.1em;
    }
    
/* 画面を狭める：主要ブロックは最大幅を統一して中央に */
#levelGirlContainer, #partButtons, #statsBox, #test-section, #weeklyAnswersBox, #wordContainer, #pagination, #partPagination  {
  max-width: 420px;
  margin-left: auto;
  margin-right: auto;
}

/* 単語カード：デフォも少しコンパクトに */
.word-card{
  padding: 10px 12px;
  margin: 10px auto;
}

/* 画像を小さめ固定比率に */
.word-card img{
  width: 88px;
  height: 132px;          /* 3:2～3:5程度に収める */
  object-fit: cover;
  border-radius: 8px;
}

/* ===== モバイル最適化 ===== */
@media (max-width: 480px){

   body.swipe-open{ overflow:hidden; }               /* 背景スクロール停止 */

  #swipeModeBox.fullscreen{
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;            /* 旧端末フォールバック */
    height: 100svh;           /* iOS 15+ */
    height: 100dvh;           /* 新しい動的vh */
    background:#fff;
    z-index: 10000;
    margin: 0;
    padding:
      max(8px, env(safe-area-inset-top))
      8px
      max(10px, env(safe-area-inset-bottom));
    display: grid;
    grid-template-rows: auto 1fr auto;  /* 上:HUD / 中:デッキ / 下:ヒント */
    gap: 6px;
  }

  /* 中央のデッキは残り領域をフルで使う */
  #swipeDeck{ height: auto; display: grid; align-items: center; }

  /* カードを画面いっぱいに拡大（はみ出さないよう clamp） */
  .swipe-card{
    width: min(92vw, 560px);
    height: clamp(320px, 74dvh, 720px);
  }

  /* HUD/ヒントを固定っぽく見せる（スクロールでずれない） */
  .swipe-hud{ position: sticky; top: 0; background:#fff; padding-bottom: 4px; }
  .swipe-hints{ position: sticky; bottom: 0; background:#fff; padding-top: 4px; }

  /* 以前の「全ボタン幅90%」をやめる：縦の伸び防止 */
  button{ font-size: 0.95rem; padding: 10px; }

  /* 必要な場所だけ幅広ボタンにする */
  #wordContainer .word-card button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: 100%;
    max-width: 320px;
  }

  /* 単語カード：2カラム化で縦長を解消 */
  .word-card{
    display: grid;
    grid-template-columns: 88px 1fr;
    grid-template-areas:
      "img text"
      "img action";
    align-items: center;
    gap: 8px 10px;
    font-size: 0.95rem;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; }
  .wc-actions{ grid-area: action; }

  .word-card strong{ display:block; margin-bottom: 4px; font-size: 1rem; }
  .word-card .meta{ color:#666; font-size: .85rem; margin-bottom: 4px; }

  /* ヒーローの女の子動画の高さを抑える */
  #levelGirlContainer video{ width: 160px; }
  #statsBox{ padding: 12px; }
  #weeklyAnswersBox{ padding: 0 4px; }
}


    .locked {
      background: #ffdddd;
      padding: 10px;
      text-align: center;
    }
    
    .musou-card {
	  background: #fff5f5;
	  border: 1px solid #f48fb1;
	  border-radius: 10px;
	  padding: 10px;
	  margin: 10px 0;
	}
    

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 20px;
      background-color:#e91e63;
      color: white;
      font-size: 1rem;
      margin: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #f50057;
    }
    
#user-info {
  text-align: left; /* ← 中央から左寄せに変更 */
  margin: 10px 0 20px;
  font-size: 1.1rem;
  padding-left: 10px;
}

#bgEffect {
  position: absolute;
  width: 180px;
  height: 180px;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: -1;
}

.star-bg {
  background: radial-gradient(circle, #fff 20%, transparent 70%);
  animation: sparkle 1.5s infinite alternate;
}

.heart-bg{ background: radial-gradient(circle,#ffd1e6 30%, transparent 70%); }

@keyframes sparkle {
  0% { opacity: 0.6; transform: scale(1); }
  100% { opacity: 1; transform: scale(1.05); }
}


#planText {
  text-align: left; /* ← 中央から左寄せに変更 */
  color: #333;
  font-weight: bold;
}

/* Partボタン（共通） */
#partButtons{
  display:flex;
  gap:8px;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  flex-wrap:nowrap;
  justify-content:flex-start; /* PCで中央寄せに上書き */
  padding-top:max(6px, env(safe-area-inset-top));
}
#partButtons button{ flex:0 0 auto; }
    
    #statsBox {
  background: #fff3f8;
  border: 1px solid #ff99c9;
  border-radius: 12px;
  padding: 15px;
  margin: 15px auto;
  max-width: 500px;
  box-shadow: 2px 2px 6px rgba(0,0,0,0.05);
  font-weight: bold;
  font-size: 1rem;
}

#learningStatus {
  text-align: center;
  margin-bottom: 10px;
  color: #333;
}

#subStats {
  display: flex;
  justify-content: space-between;
  font-size: 0.95rem;
  padding: 0 10px;
  color: #555;
}

#subStats div {
  flex: 1;
  text-align: center;
}
    
    
    

    #loginBonusPopup {
      display: none;
      position: fixed;
      top: 10%;
      left: 5%;
      width: 90%;
      height: 75%;
      background: white;
      border: 2px solid #ccc;
      z-index: 9999;
      padding: 20px;
      overflow: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    
    .swal2-popup.premium-popup {
  font-family: 'sans-serif';
  border-radius: 15px;
  padding: 20px;
  max-width: 400px;
}

    #stampGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 10px;
    }

    #test-section {
      text-align: center;
      margin: 20px 0;
    }

    #videoModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    video {
      width: 90%;
      max-height: 80vh;
    }

  /* 必要な場所だけ個別に幅を広げたい場合は明示的に指定 */
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: 90%;
    max-width: 320px;
  }

  /* Partボタンを横一列でスワイプ可能に */
  #partButtons {
    display: flex;
    gap: 8px;
    overflow-x: auto;           /* ← 横スクロール */
    -webkit-overflow-scrolling: touch;
    flex-wrap: nowrap;          /* 折り返さない */
    justify-content: flex-start;
    padding-top: max(6px, env(safe-area-inset-top));
  }
  #partButtons button {
    flex: 0 0 auto;             /* 収縮させない */
  }

.word-card {
        font-size: 0.9rem;
}
.btn { padding:10px 16px; border-radius:8px; border:none; cursor:pointer; }
.btn-primary { background:#e91e63; color:#fff; }
.btn-secondary { background:#999; color:#fff; }
    
.btn-premium {
    background-color: #e91e63;
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: 6px;
    font-size: 1em;
    margin-top: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.btn-premium:hover {
    background-color: #d81b60;
}
  
  /* 既存CSSの末尾に追加 */
.hidden{display:none;}

#swipeModeBox{
  max-width:700px;margin:16px auto;padding:10px;
}
#swipeDeck{
  position:relative;height:360px;user-select:none;touch-action:pan-y;
}
.swipe-card{
  position:absolute;inset:0;margin:auto;width:92%;max-width:580px;height:340px;
  background:#fff;border-radius:14px;border:1px solid #eee;
  box-shadow:0 10px 24px rgba(0,0,0,.08);
  padding:18px;display:flex;flex-direction:column;justify-content:center;align-items:center;
  transition:transform .2s ease, opacity .2s ease;
}
.swipe-word{font-size:28px;font-weight:700;margin-bottom:8px;}
.swipe-mean{color:#555;margin-bottom:12px;}
.swipe-img{
  width:220px;height:300px;object-fit:cover;border-radius:10px;background:#f2f2f2;
  -webkit-user-drag: none;      /* Safari/Chrome */
  user-drag: none;
  user-select: none;
  pointer-events: none;          /* ← ドラッグの起点を常にカードにする */
}

.swipe-badge{
  position:absolute;top:12px;font-weight:700;padding:6px 10px;border-radius:8px;opacity:0;
}
.badge-left{left:12px;background:#fde68a;color:#92400e;}     /* 覚えてない */
.badge-right{right:12px;background:#dcfce7;color:#166534;}    /* 覚えた */

.swipe-hud{display:flex;justify-content:space-between;align-items:center;margin:6px 6px 10px;}
.swipe-hints{display:flex;justify-content:space-between;color:#888;margin-top:6px;padding:0 4px;}
@media (prefers-reduced-motion: reduce){
  .swipe-card{ transition: none; }
  .star-bg{ animation: none; }
  .caption{ display: none !important; }
}

/* ===== Desktop layout improvements ===== */
/* Desktop */

  /* 単語カード：3カラム（画像 / テキスト / アクション） */
  .word-card{
    display: grid;
    grid-template-columns: 140px 1fr auto;
    grid-template-areas: "img text action";
    align-items: center;
    gap: 12px 16px;
    padding: 14px 16px;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; }
  .wc-actions{ grid-area: action; justify-self: end; }

  .word-card img{ width: 140px; height: 210px; }

  /* PCではボタン幅を自動 */
  #test-section button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: auto;
    max-width: none;
  }

  /* パートボタン/ページネーションの中央寄せ */
  #partButtons{ justify-content: center; overflow: visible; flex-wrap: wrap; }
  .pagination{ justify-content: center; overflow: visible; }

/* ヒーロー背景のピンク丸はモバイルだけ表示、PCでは非表示 */
#levelGirlContainer{ position: relative; }
@media (min-width: 600px){ #bgEffect{ display:none; } }

/* --- Login Bonus modal --- */
/* これに統一：JSで display を切り替える（flexはJSで当てる） */
#loginBonusPopup{
  display:none;           /* ← ここは none のまま */
  position:fixed;
  inset:4vh 3vw;
  background:#fff;
  border:2px solid #ccc;
  border-radius:12px;
  z-index:9999;
  box-shadow:0 8px 20px rgba(0,0,0,.15);
  padding:12px 12px 0;
  overflow:hidden;
  /* display:flex;  ← 削除！*/
  /* flex-direction:column; ← 削除！*/
}
#stampScroll{
  flex:1;                 /* ここがスクロール領域 */
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  padding:8px 2px 12px;
}
#stampGrid{
  display:grid;
  grid-template-columns: repeat(6, minmax(50px,1fr));
  gap:10px;
}
#loginBonusOkBtn{
  position:sticky; bottom:0;
  margin:8px auto calc(env(safe-area-inset-bottom) + 8px);
  width:min(380px, 90%);
}

/* 末尾に追記：位置を詰める */
#swipeModeBox{
  margin: 8px auto 0 !important;   /* 上の余白を小さく */
}
#swipeDeck{
  height: 340px !important;        /* わずかに浅くして画面上寄せ */
}
.swipe-hud{ margin: 4px 6px 8px !important; }

/* モバイルでは列数を減らしOKを押しやすく */
@media (max-width:480px){
  #stampGrid{ grid-template-columns: repeat(4, minmax(56px,1fr)); }
}

/* モーダル時は背景スクロールを止める */
body.modal-open{ overflow:hidden; height:100vh; }

/* CSSの一番最後に追加（スマホ全画面時の“勝ち”ルール） */
@media (max-width:480px){
  #swipeModeBox.fullscreen .swipe-card{
    height: clamp(320px, 74dvh, 720px) !important;
    width: min(92vw, 560px);
  }
  #swipeModeBox.fullscreen #swipeDeck{
    height: auto !important;
    min-height: 74dvh; /* 念のため */
  }
	
  #swipeModeBox:not(.fullscreen) #swipeDeck{
    height: 340px;            /* ← 通常表示のときだけ適用 */
  }
}

/* ===== Centering fixes (override) ===== */
#levelGirlContainer,
#test-section,
#weeklyAnswersBox,
#partButtons,
#wordContainer,
#pagination,
#partPagination {
  margin-left: auto !important;
  margin-right: auto !important;
  text-align: center !important;
}

#partButtons { justify-content: center !important; }
#test-section button, #swipeStartBtn { width: min(320px, 90%); }

/* テストボタンを横並びに */
#test-section{
  display:flex;
  justify-content:center;
  gap:10px;
  flex-wrap:wrap;
}
#test-section button{
  width:auto !important;   /* 上の “幅100%” 指定を打ち消す */
}

button:focus-visible { outline: 3px solid #e91e63; outline-offset: 2px; }

/* pagination condensed */
.pagination .ellipsis{
  padding: 0 6px;
  color:#888;
  align-self:center;
}
.pagination button.active{
  background-color:#d81b60;
  font-weight:700;
}
.pagination button[disabled]{
  opacity:.5;
  cursor: default;
}

	
  #partButtons{ justify-content: center; overflow: visible; flex-wrap: wrap; }
  .pagination{ justify-content: center; overflow: visible; }

  /* ページネーションも横並びスクロールで省スペース */
  .pagination{
    display:flex;
    gap:8px;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
    flex-wrap:nowrap;
    justify-content:center;
    padding:6px 2px;
  }
  .pagination button{
    flex:0 0 auto;
    min-width:44px;
    height:36px;
  }
  #partPagination, .pagination{
    display:flex;
    justify-content:center;
    width:100%;
    max-width:420px;
    margin:0 auto;
  }

  /* ページネーション（共通/凝縮） */
.pagination{
  display:flex;
  gap:8px;
  overflow-x:auto;
  -webkit-overflow-scrolling:touch;
  flex-wrap:nowrap;
  justify-content:center;
  padding:6px 2px;
}
	  
.pagination .ellipsis{ padding:0 6px; color:#888; align-self:center; }
.pagination button.active{ background-color:#d81b60; font-weight:700; }
.pagination button[disabled]{ opacity:.5; cursor:default; }

@media (min-width: 768px){
  /* 単語カード：3カラム（画像 / テキスト / アクション） */
  .word-card{
    display: grid;
    grid-template-columns: 140px 1fr auto;
    grid-template-areas: "img text action";
    align-items: center;
    gap: 12px 16px;
    padding: 14px 16px;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; }
  .wc-actions{ grid-area: action; justify-self: end; }

  .word-card img{ width: 140px; height: 210px; }

  #test-section button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: auto;
    max-width: none;
  }
}
　/* === スクショ再現用の最終上書き === */

/* デスクトップ：幅と左寄せ */
@media (min-width: 768px){
  /* 統一幅：ステータス枠や週間グラフは中くらい、単語リストは広め */
  #statsBox{ max-width: 760px; }
  #weeklyAnswersBox{ max-width: 760px; }
  #wordContainer{ max-width: 920px; text-align: initial !important; }
  #pagination{ max-width: 920px; }

  /* 単語カード：画像/本文/アクションの3カラムレイアウト */
  .word-card{
    display: grid;
    grid-template-columns: 140px 1fr auto;
    grid-template-areas: "img text action";
    align-items: center;
    gap: 12px 16px;
    padding: 14px 16px;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; text-align: left; }
  .wc-actions{ grid-area: action; justify-self: end; }

  .word-card img{ width: 140px; height: 210px; object-fit: cover; border-radius: 8px; }
}

/* モバイル：2カラムで縦長を解消（既存と同方向の上書き） */
@media (max-width: 480px){
  #wordContainer{ max-width: 420px; text-align: initial !important; }

  .word-card{
    display: grid;
    grid-template-columns: 88px 1fr;
    grid-template-areas:
      "img text"
      "img action";
    align-items: center;
    gap: 8px 10px;
    padding: 10px 12px;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; text-align: left; }
  .wc-actions{ grid-area: action; justify-self: start; }

  .word-card img{ width: 88px; height: 132px; object-fit: cover; border-radius: 8px; }
}

/* パートボタン＆ページネーションの見た目（ピル型/中央寄せ） */
#partButtons{ justify-content: center !important; overflow: visible; flex-wrap: wrap; }
#partButtons button,
.pagination button{
  border-radius: 9999px;
  padding: 10px 16px;
}

/* ステータス枠の色味はスクショ準拠のピンク系に */
h1, h3, #learningStatus{ color: #e91e63; }

/* 単語カード内の文字サイズと余白を微調整 */
.word-card strong{ display:block; margin-bottom: 4px; font-size: 1rem; }
.word-card .meta{ color:#666; font-size:.85rem; margin-bottom:4px; }

/* “中央寄せ強制”を打ち消し（既存の !important に勝つため再宣言） */
#wordContainer, #wordContainer *{ text-align: initial !important; }

/* === Weekly chart (screenshot style) === */
#weeklyAnswersBox{ max-width:760px; margin:20px auto; }
.weekly-wrap{
  background:#fff3f8; border:1px solid #ff99c9; border-radius:12px;
  padding:8px 6px;
}
.weekly-bars{
  display:flex; gap:12px; justify-content:space-between; align-items:flex-end;
  height:160px;
}
.weekly-day{
  flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-end;
}
.weekly-num{ font-size:.8rem; color:#e91e63; margin-bottom:6px; }
.weekly-bar{
  width:26px; border-radius:10px; box-shadow:0 2px 6px rgba(0,0,0,.08);
  background:linear-gradient(180deg,#ff7bbd,#ffb3d9);
}
.weekly-labels{
  display:flex; gap:12px; justify-content:space-between;
  font-size:.8rem; color:#555; margin-top:6px;
}
.weekly-label{ flex:1; text-align:center; }
@media (max-width:480px){
  .weekly-bars{ height:140px; gap:8px; }
  .weekly-bar{ width:22px; }
}

/* --- HOTFIX 2025-09-03 ------------------------------------ */
/* ① ボタンが縦書きになるのを強制で止める（横書き＆折返し禁止） */
.wc-actions button{
  writing-mode: horizontal-tb !important;
  text-orientation: mixed !important;
  transform: none !important;
  white-space: nowrap;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

/* ② 週間グラフがスマホで消えるのを防ぐ（高さ/表示の保険） */
#weeklyBars, #weeklyLabels { display: flex !important; }
.weekly-bars { min-height: 140px; }
.weekly-bar  { width: 22px; min-height: 6px; }

/* ③ “ガタガタ”対策：横スクロール禁止＋画像のサイズを固定 */
html, body { overflow-x: hidden; }
img, video { max-width: 100%; height: auto; }

/* 単語カードの画像サイズを固定（崩れ防止） */
.word-card img { width: 88px; height: 132px; object-fit: cover; }

/* ④ PC時にアクション列が狭くなり過ぎないように幅を確保 */
@media (min-width: 481px){
  .word-card { grid-template-columns: 110px 1fr 180px; }
}
@media (max-width: 480px){
  .wc-actions { width: 100%; }
  .wc-actions button { width: 100%; }
}

/* ボタンを必ず横書き・1行・グリッドの専用列に */
.wc-actions{ width:100%; display:flex; flex-direction:column; gap:6px; }
.wc-actions button{
  writing-mode: horizontal-tb !important;
  text-orientation: mixed !important;
  white-space: nowrap;
  width: 100%;
}

/* ステータス行をブロック化してボタンと重ならないように */
.wc-body .meta{ display:block; line-height:1.5; }

/* PC時はアクション列の最小幅を確保 */
@media (min-width: 481px){
  .word-card{ grid-template-columns: 110px 1fr 180px; }
}

#weeklyBars, #weeklyLabels{ display:flex !important; }
.weekly-bars{ min-height:140px; align-items:flex-end; }
.weekly-bar { width:22px; min-height:6px; }
@media (min-width:481px){ .weekly-bars{ min-height:160px; } .weekly-bar{ width:26px; } }


/* ⑤ 念のため全ボタンも強制横書き */
button { writing-mode: horizontal-tb; }

/* --- 固定レイアウト（ボタン“ガタガタ”防止） --- */
:root{
  --card-img-w: 88px;
  --card-img-h: 132px;
  --card-action-w: 220px; /* ← ボタン列の固定幅（PC時） */
}

/* 画像は常に同じサイズで確保（読み替え時の揺れ防止） */
.word-card img{
  width: var(--card-img-w) !important;
  height: var(--card-img-h) !important;
  object-fit: cover;
  border-radius: 8px;
}

/* PC幅は 画像 / 本文 / ボタン列 の3カラムでボタン列を固定幅に */
@media (min-width: 769px){
  .word-card{
    grid-template-columns: var(--card-img-w) 1fr var(--card-action-w) !important;
    grid-template-areas: "img text action";
  }
  .wc-actions{
    width: var(--card-action-w);
    justify-self: end;
  }
}

/* モバイルでは wc-actions を100%幅で縦積み（幅は一定） */
@media (max-width: 768px){
  .wc-actions{ width: 100%; display:flex; flex-direction:column; gap:6px; }
  .wc-actions button{ width: 100%; }
}

/* ボタンは必ず横書き・1行にして幅ブレ防止 */
.wc-actions button{
  writing-mode: horizontal-tb !important;
  white-space: nowrap;
  display: inline-flex; align-items:center; justify-content:center;
}

/* “画像パス”行が長くて横幅を押し広げないよう省略表示 */
#wordContainer span[id^="imgpath-"]{
  display:inline-block; max-width:100%;
  overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
}

/* --- 週次グラフ：スマホ(～768px)でも必ず表示 --- */
@media (max-width: 768px){
  #weeklyAnswersBox{ display:block !important; }
  #weeklyAnswersBox .weekly-wrap{ display:block !important; }
  #weeklyBars, #weeklyLabels{ display:flex !important; }
  .weekly-bars{ min-height:140px !important; gap:8px; }
  .weekly-bar{ width:22px !important; min-height:6px; }
}

  /* バッジの見た目 */
  #cardCounter {
    position:absolute; top:-10px; right:-10px;
    background:#e91e63; color:#fff; font-size:14px; font-weight:700;
    padding:4px 8px; border-radius:12px; box-shadow:0 1px 4px rgba(0,0,0,.2);
    cursor:pointer; user-select:none; transition:opacity .2s ease;
  }
  /* 広告成功での“ご褒美”演出（大きめ＆黄色に発光） */
  @keyframes popGlow {
    0%   { transform:scale(1);   background:#e91e63; box-shadow:0 0 4px rgba(233,30,99,.5); }
    40%  { transform:scale(1.3); background:#ffeb3b; box-shadow:0 0 16px rgba(255,235,59,.9); }
    100% { transform:scale(1);   background:#e91e63; box-shadow:0 0 4px rgba(233,30,99,.5); }
  }
  .pop-glow { animation:popGlow .8s ease-out; }

  /* 毎回更新時の軽いポン演出（色は固定） */
  @keyframes popSoft {
    0%   { transform:scale(1); }
    50%  { transform:scale(1.12); }
    100% { transform:scale(1); }
  }
  .pop-soft { animation:popSoft .25s ease-out; }

#cardCounter { transition: transform .18s ease, background-color .18s ease, opacity .18s ease; }
.pop-soft { animation: pop .18s ease; }
.pop-glow { animation: pop .22s ease; background-color: #ffd54f !important; } /* 一瞬ご褒美色 */

#cardCounter.pop-glow { animation: pop .28s ease; box-shadow: inset 0 0 .6rem rgba(255,215,64,.65); }
#cardCounter.pop-soft { animation: pop .2s ease; }

#cardWrap{ position:relative; }
#cardCounter{
  position:absolute; top:-8px; right:-8px;
  z-index: 5;  /* ← これで常に前面 */
}

/* === FINAL LAYOUT FIX === */
*,*::before,*::after{ box-sizing:border-box; }
:root{ --imgW:88px; --imgH:132px; --actionsW:220px; }

/* モバイル基準（画像/本文/ボタン） */
.word-card{
  display:grid;
  grid-template-columns: var(--imgW) 1fr;
  grid-template-areas:
    "img text"
    "img action";
  gap:8px 10px;
  align-items:center;
  padding:10px 12px;
}
.wc-img{ grid-area:img; }
.wc-body{ grid-area:text; text-align:left; }
.wc-actions{ grid-area:action; width:100%; display:flex; flex-direction:column; gap:6px; }
.word-card img{ width:var(--imgW); height:var(--imgH); object-fit:cover; border-radius:8px; }

/* デスクトップ：ボタン列を固定幅にして揺れ防止 */
@media (min-width:768px){
  .word-card{
    grid-template-columns: var(--imgW) 1fr var(--actionsW);
    grid-template-areas:"img text action";
    padding:14px 16px;
    gap:12px 16px;
  }
  .wc-actions{ width:var(--actionsW); justify-self:end; }
}

/* ボタンは必ず横書き・1行 */
.wc-actions button{
  writing-mode: horizontal-tb !important;
  white-space: nowrap;
  display:inline-flex; align-items:center; justify-content:center;
}

#cardWrap { display: none !important; }

/* ← 既存CSSの末尾に追加 */
.wc-head{ display:flex; align-items:center; gap:8px; flex-wrap:nowrap; }
.wc-head strong{ margin:0; }  /* 1行に並べるため */
.remaining-inline{
  display:inline-flex; align-items:center;
  padding:2px 8px; border-radius:9999px;
  font-size:.8rem; line-height:1.4;
  background:#e91e63; color:#fff; white-space:nowrap;
}
.remaining-inline.is-premium{ background:#4caf50; } /* 無制限用 */

.wc-actions{ contain: layout; }           /* 周囲へのレイアウト波及を抑制 */
.wc-actions button{
  min-height: 40px;                       /* ボタン高さを固定 */
  white-space: nowrap;                    /* 折返し禁止 */
  letter-spacing: .02em;
  font-weight: 600;
}

/* ==== FIX pack 2025-09-09 ===================================== */
/* 画像・アクション列の幅を固定して“列ブレ”を根絶 */
:root{ --imgW:88px; --imgH:132px; --actionsW:220px; }

/* PC：画像/本文/ボタンの3カラム。ボタン列は固定幅 */
.word-card{
  display:grid;
  grid-template-columns: var(--imgW) 1fr var(--actionsW);
  gap:12px 16px;
  align-items:center;
  padding:12px 14px;
}
.wc-img{ grid-area:auto; }
.wc-body{ min-width:0; }           /* ← これで本文側の伸縮による崩れを防止 */
.wc-actions{
  width:var(--actionsW);
  justify-self:end;
  display:flex;
  flex-direction:column;
  gap:8px;
  contain:layout;                  /* レイアウト波及を遮断（微振れ防止） */
}

/* モバイル：2カラム+下段にボタン列。横幅100%で一列に */
@media (max-width:480px){
  .word-card{
    grid-template-columns: var(--imgW) 1fr;
    grid-template-areas:"img text" "img action";
  }
  .wc-actions{ width:100%; justify-self:stretch; }
}

/* ボタンは必ず1行・同じ高さ・同じ幅 → “ガタガタ”を封じる */
.wc-actions > button{
  width:100%;
  min-height:44px;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  writing-mode:horizontal-tb !important;
}

/* 英単語は1行表示（長い語は省略）→ 2行化の解消 */
.wc-head{ display:flex; align-items:center; gap:8px; min-width:0; }
.wc-head strong{
  flex:1 1 auto;
  min-width:0;
  white-space:nowrap;
  overflow:hidden;
  text-overflow:ellipsis;
  line-height:1.2;
}

/* 「残り6枚」ピルは折り返し禁止。長文でも横幅を押し広げない */
.remaining-inline{ flex:0 0 auto; white-space:nowrap; }

/* 画像は常に同サイズ。読み込み遅延でも縦横が揺れない */
.word-card img{
  width:var(--imgW);
  height:var(--imgH);
  object-fit:cover;
  border-radius:8px;
}

/* 一覧コンテナの幅を統一（中央寄せ）*/
#wordContainer{ max-width:920px; margin:0 auto; }

/* === mobile CTA: 幅/位置/高さを統一 === */
@media (max-width:480px){
  #adCtaBtn,
  #test-section button,
  #swipeStartBtn{
    display:block;
    width:min(320px, 90%);
    margin:10px auto;
    min-height:44px;
  }
  /* test-sectionは縦積みにして揺れを無くす */
  #test-section{ display:block !important; text-align:center; }
  #test-section button{ width:min(320px, 90%) !important; margin:10px auto 0; }
}

/* === mobile: スワイプHUDの重なり解消（2行グリッド） === */
@media (max-width:480px){
  #swipeModeBox .swipe-hud{
    position: sticky; top:0; background:#fff;
    display:grid !important;
    grid-template-columns: auto 1fr;
    grid-template-areas:
      "back counter"
      "back stats";
    align-items:center;
    gap:6px 8px;
    padding-bottom:4px;
  }
  #swipeExitBtn{ grid-area:back; }
  #swipeCounter{ grid-area:counter; justify-self:end; }
  #swipeStats{ grid-area:stats;   justify-self:end; font-size:.9rem; }
}

/* === mobile: 一覧に戻るボタンは横一行・自動幅 === */
@media (max-width:480px){
  #swipeModeBox .swipe-hud button{
    width:auto !important;
    white-space:nowrap;
  }
}

/* CTA行の並びと幅を統一 */
#test-section.cta-row{
  display:flex !important;
  gap:10px;
  flex-wrap:wrap;
  justify-content:center;
}
#test-section.cta-row > button{
  flex: 1 1 240px;     /* 最小幅240、余れば伸びる */
  min-width: 200px;
  max-width: 320px;
}

/* スマホは“2列”で並べる（3つ目は次の段に回る） */
@media (max-width:480px){
  #test-section.cta-row > button{
    flex: 1 1 calc(50% - 12px);
    min-width: 160px;
  }
}

/* === ここからNEW：3タブ＋固定タブバー用の最小追記 ========== */

    /* 3つのビュー（main）を切替。is-activeだけ表示 */
    .app-view{ display:none; padding-bottom: calc(56px + env(safe-area-inset-bottom)); }
    .app-view.is-active{ display:block; }

    /* 画面下の固定タブバー */
    .tabbar{
      position: fixed; left: 0; right: 0; bottom: 0;
      height: 56px;
      padding-bottom: env(safe-area-inset-bottom);
      background: #fff; border-top: 1px solid #eee;
      display: grid; grid-template-columns: repeat(3,1fr);
      z-index: 9998;
    }
    .tabbar .tab{
      appearance: none; background: none; border: 0; margin: 0;
      font: inherit; color: #555;
      display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px;
      cursor:pointer;
    }
    .tabbar .tab i{ font-size: 18px; }
    .tabbar .tab.is-active{ color: #e91e63; font-weight: 700; }

    /* ネイティブのAdMobバナーに重ならないための余白 */
    #adSpacer{ height: 0px; }

    /* ビュー幅の統一（既存のmax-width指定に馴染ませる） */
    .app-view > * { max-width: 920px; margin-left:auto; margin-right:auto; }

		/* --- Test CTA を縦一列・同じ幅で統一 --- */
	#test-section.cta-col{
	  display:flex !important;
	  flex-direction:column !important;
	  align-items:center !important;
	  gap:12px !important;
	  text-align:center !important;
	}
	
	#test-section.cta-col > button{
	  width:min(420px, 92%) !important;
	  min-height:44px !important;
	  border-radius:9999px !important;
	}
	
	/* 既存の“横並び”指定を無効化 */
	#test-section.cta-row{ display:block !important; }

	/* バナーは常に枠を確保（ブロッカー時のガタつき防止） */
	.ad-banner { min-height:60px; display:flex; align-items:center; justify-content:center; margin:8px 8px calc(8px + env(safe-area-inset-bottom, 0px)); }
	.ad-banner.fallback { background:#ffe6ef; color:#ef2a67; font-size:12px; border-radius:12px; padding:8px 12px; }
	
	.app-footer { padding-bottom: env(safe-area-inset-bottom, 0px); }


  </style>
	<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

　<style>
  /* 設定モーダルのボタンを強制整形 */
  #by-delete-btn{
    display:flex !important;
    align-items:center !important;
    justify-content:center !important;
    width:100% !important;
    min-height:44px !important;
    padding:12px !important;
    border:none !important;
    border-radius:10px !important;
    background:#ef4444 !important;
    color:#fff !important;
    font-size:16px !important;
    font-weight:700 !important;
    line-height:1.2 !important;
    text-indent:0 !important;
    letter-spacing:normal !important;
    text-transform:none !important;
    white-space:nowrap !important;
  }
  /* アイコンフォントや汎用CSSで文字を隠すパターンの無効化 */
  #by-delete-btn::before,
  #by-delete-btn::after{
    content:none !important;
    display:none !important;
  }
</style>

</head>
<body>

<!-- スタンプカードポップアップ -->
<div id="loginBonusPopup">
  <h3 id="loginBonusTitle">ログインボーナス</h3>
  <div id="stampScroll"><div id="stampGrid"></div></div>
  <button id="loginBonusOkBtn" onclick="closeLoginBonus()">OK</button>
</div>


<!-- ================== 3つのビュー ================== -->
<!-- トップページ -->
<main id="view-home" class="app-view is-active">
  <!-- ユーザー情報＋設定ボタン -->
<!-- ユーザー情報＋アカウント削除ボタン（直置き） -->
<div id="by-header" style="margin:8px 12px;">
  <div id="user-info" style="display:flex; flex-direction:column; gap:8px;">
    <div id="username"></div>
    <div id="planText"></div>
    <div id="userLevel"></div>

    <!-- ★ 直置きの削除ボタン -->
    <button id="by-delete-btn" type="button" aria-label="アカウント削除"
      style="
        display:flex !important; align-items:center !important; justify-content:center !important;
        width:180px !important; min-height:44px !important; padding:10px 14px !important;
        border:none !important; border-radius:10px !important;
        background:#ef4444 !important; color:#fff !important;
        font-size:16px !important; font-weight:700 !important; line-height:1.2 !important;
        letter-spacing:normal !important; text-indent:0 !important; text-transform:none !important;
        white-space:nowrap !important; cursor:pointer !important;
      ">
      <span style="pointer-events:none">アカウント削除</span>
    </button>
  </div>
</div>

  </div>

  <div id="levelGirlContainer" class="level-girl">
    <div id="bgEffect" class="star-bg"></div>
    <video id="girlVideo" preload="metadata" autoplay muted loop playsinline width="180"></video>
  </div>

  <div id="statsBox">
    <div id="learningStatus" aria-live="polite"></div>
    <div id="subStats">
      <div id="loginDays"></div>
      <div id="testStats"></div>
    </div>
  </div>

  <div id="weeklyAnswersBox">
    <h3>1週間の解答数:(目標解答数:80が目安)</h3>
    <div class="weekly-wrap">
      <div id="weeklyBars" class="weekly-bars"></div>
    </div>
    <div id="weeklyLabels" class="weekly-labels"></div>
  </div>
</main>

<!-- ▼ 設定モーダル（※1つだけ） -->
<div id="by-settings-modal" role="dialog" aria-modal="true" aria-labelledby="by-settings-title"
     style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.35);z-index:9999;">
  <div style="max-width:560px;margin:10vh auto;background:#fff;border-radius:14px;overflow:hidden;box-shadow:0 10px 30px rgba(0,0,0,.15)">
    <div style="padding:14px 16px;border-bottom:1px solid #f1f5f9;display:flex;justify-content:space-between;align-items:center;">
      <h2 id="by-settings-title" style="margin:0;font-size:18px;">設定</h2>
      <button id="by-close" style="border:none;background:transparent;font-size:20px;cursor:pointer;" aria-label="閉じる">×</button>
    </div>

    <div style="padding:16px;display:grid;gap:12px;">
      <a href="/privacy.html" style="color:#0ea5e9;text-decoration:none">プライバシーポリシー</a>
      <a href="/terms.html" style="color:#0ea5e9;text-decoration:none">利用規約</a>

      <hr style="border:none;border-top:1px solid #f1f5f9;margin:8px 0;">

      <button id="by-delete-btn"
        style="padding:12px;border-radius:10px;background:#ef4444;color:#fff;border:none;cursor:pointer;font-weight:600;">
        アカウント削除
      </button>
      <p style="font-size:12px;color:#64748b;margin:0;">
        削除は取り消せません。サーバー上の学習履歴・アカウント情報は完全に消去されます。
      </p>
    </div>
  </div>
</div>
<!-- ▲ 設定モーダル -->

<script>
  // ==== 二重初期化ガード ====
  if (!window.__byInit) {
    window.__byInit = true;

    const byOpen  = document.getElementById('by-settings-btn');
    const byModal = document.getElementById('by-settings-modal');
    const byClose = document.getElementById('by-close');
    const byDelete = document.getElementById('by-delete-btn');

    byOpen?.addEventListener('click', () => { byModal.style.display = 'block'; });
    byClose?.addEventListener('click', () => { byModal.style.display = 'none'; });
    byModal?.addEventListener('click', (e) => { if (e.target === byModal) byModal.style.display = 'none'; });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') byModal.style.display = 'none'; });

    // 退会（多重タップ防止＋簡易ローディング）
    let deleting = false;
    byDelete?.addEventListener('click', async () => {
      if (deleting) return;
      if (!confirm('本当にアカウントを削除しますか？この操作は取り消せません。')) return;

      deleting = true;
      const origLabel = byDelete.textContent;
      byDelete.disabled = true;
      byDelete.textContent = '削除中…';

      try {
        const res = await fetch('/api/account/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          // 認証やCSRFが必要なら適宜追加:
          // credentials: 'include',
          // headers: { 'X-CSRF-TOKEN': token, ... }
        });

        if (res.ok || res.status === 204) {
          await byClearLocalData();
          alert('アカウントを削除しました。ご利用ありがとうございました。');
          location.href = '/start.html';
        } else {
          alert('削除に失敗しました。時間をおいて再度お試しください。');
        }
      } catch {
        alert('通信エラーが発生しました。');
      } finally {
        deleting = false;
        byDelete.disabled = false;
        byDelete.textContent = origLabel;
      }
    });

    async function byClearLocalData() {
      try {
        localStorage.clear(); sessionStorage.clear();
        document.cookie.split(';').forEach(c => {
          const eq = c.indexOf('=');
          const name = eq > -1 ? c.slice(0, eq) : c;
          document.cookie = name.trim() + '=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/';
        });
        if (indexedDB && indexedDB.databases) {
          const dbs = await indexedDB.databases();
          await Promise.all(dbs.map(db => new Promise((resolve) => {
            const req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = req.onblocked = () => resolve();
          })));
        }
      } catch {}
    }
  }

　// ネイティブ連携（Capacitor/WKWebView）あり・なし両対応。
// 1) setAdPendingToggle + showAd パターン（あなたのiOS実装）
// 2) window.webkit.messageHandlers.showRewarded パターン（汎用）
// 3) それ以外はブラウザ用ダミー（レビュー前の動作確認用）
function showRewardedAd() {
  return new Promise((resolve) => {
    // ① あなたの既存ネイティブ連携（推奨）
    if (typeof window.setAdPendingToggle === 'function' && typeof window.showAd === 'function') {
      window.setAdPendingToggle(() => resolve());
      window.showAd();
      return;
    }
    // ② WebKit message handler 形式（用意していれば）
    if (window.webkit?.messageHandlers?.showRewarded) {
      window.__onRewarded = () => { try { resolve(); } catch(_){} };
      try { window.webkit.messageHandlers.showRewarded.postMessage({}); } catch(_) { resolve(); }
      return;
    }
    // ③ ブラウザ用ダミー（開発・Render上）
    alert('広告（ダミー表示）: 本番アプリでは動画が再生されます。');
    resolve();
  });
}
</script>

<!-- テスト受検ページ -->
<main id="view-test" class="app-view">
  <div id="test-section" class="buttons">
    <!-- 広告版はJSで free & 広告可のときだけ表示 -->
	<button id="startTestBtn"      class="pink-btn">テストを開始する</button>
	<button id="startWordModeBtn"  class="pink-btn">テストを開始する(単語モード)</button>
	<button id="startSwipeBtn"     class="pink-btn">スワイプ学習を始める</button>
  </div>

  <div id="swipeModeBox" class="hidden">
    <div class="swipe-hud">
      <button id="swipeExitBtn">一覧に戻る</button>
      <div id="swipeCounter" aria-live="polite">0 / 0</div>
      <div id="swipeStats" aria-live="polite">覚えた: 0 / 覚えたい: 0</div>
    </div>
    <div id="swipeDeck"></div>
    <div class="swipe-hints">
      <span>← 覚えてない</span><span>覚えた →</span>
    </div>
  </div>

  <div id="cardWrap">
    <div id="cardCounter">残り 0 枚</div>
    <div id="cardArea"></div>
  </div>
</main>

<!-- 単語一覧ページ -->
<main id="view-words" class="app-view">
  <div id="partButtons"></div>
  <div class="pagination" id="partPagination"></div>

  <div id="wordContainer"></div>
  <div class="pagination" id="pagination"></div>
</main>

<!-- ==== 共有フッター（※ここだけ） ==== -->
<!-- 3つの main の直後、最後に1つ置く -->
<footer class="app-footer">
  <div class="ad-banner" aria-label="広告"></div>
</footer>


  <!-- ================== /3つのビュー ================== -->

  <!-- NEW: 画面下の固定タブバー -->
  <nav id="tabbar" class="tabbar" role="tablist" aria-label="Main tabs">
    <button class="tab is-active" data-tab="home"  aria-selected="true"  role="tab">
      <i class="fa fa-house"></i><span>トップ</span>
    </button>
    <button class="tab"          data-tab="test"  aria-selected="false" role="tab">
      <i class="fa fa-graduation-cap"></i><span>テスト</span>
    </button>
    <button class="tab"          data-tab="words" aria-selected="false" role="tab">
      <i class="fa fa-book"></i><span>単語</span>
    </button>
  </nav>

  <!-- NEW: ネイティブAdMobバナー分の余白（高さはJSで調整） -->
  <div id="adSpacer" aria-hidden="true"></div>

  <!-- NEW: タブ切替＆バナー余白調整スクリプト -->

<script>

// ===== Premium bridge (Capacitor + StoreKit 2) =====
// 0) ブリッジの参照＆キャッシュ初期化（※1回だけ定義）

// === globals shared by all scripts ===
window.Cap           = window.Capacitor || null;
window.AdMob         = window.Cap?.Plugins?.AdMob || null;
window.NativePremium = window.Cap?.Plugins?.PremiumPlugin || null;

// 置き換え：apiFetch の先頭付近
const apiFetch = (path, opts = {}) => {
  const method = (opts.method || 'GET').toUpperCase();
  const needsCSRF = !['GET','HEAD','OPTIONS'].includes(method);

  // === CSRF を自動検出（Rails or Spring両対応） ===
  const pickCSRFFromPageOrCookie = () => {
    const meta = document.querySelector('meta[name="csrf-token"]')?.content; // Rails
    if (meta) return { header: 'X-CSRF-Token', token: meta };

    const ck = document.cookie;
    const mSpring = ck.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/); // Spring
    if (mSpring) return { header: 'X-CSRF-TOKEN', token: decodeURIComponent(mSpring[1]) };

    const mLegacy = ck.match(/(?:^|;\s*)_csrf=([^;]+)/);      // 旧設定
    if (mLegacy) return { header: 'X-CSRF-Token', token: decodeURIComponent(mLegacy[1]) };

    return null;
  };

  const headers = new Headers({ Accept: 'application/json', ...(opts.headers || {}) });
  if (needsCSRF && !headers.has('X-CSRF-Token') && !headers.has('X-CSRF-TOKEN')) {
    const c = pickCSRFFromPageOrCookie();
    if (c) headers.set(c.header, c.token);
  }
  return fetch(path, { credentials: 'include', ...opts, headers });
};

// === Premium state: 単一ソース化 & 早期復元 ===
// === Premium state: 単一ソース化 & 早期復元 ===
window.premiumState = window.premiumState ?? { value: false };

(function hydratePremiumEarly(){
  window.premiumState.value = false;
  // ただし iOS ネイティブからの確認で上書き（下の refreshPremium / entitlements）
})();

// どこからでもこれだけ叩けばOK（保存・UI更新まで一括）
window.setPremium = function setPremium(enabled){
  const v = !!enabled;
  window.premiumState.value = v;
  try { localStorage.setItem('app.premium', v ? '1' : '0'); } catch {}
  if (window.user) window.user.premium = v;
  try { applyPremiumUI?.(); } catch {}
};

// 判定は常にこれを使う
window.isPremium = window.isPremium ?? function(){
  return !!window.premiumState?.value;
};

// どこから来てもここだけ叩けばUI/保存まで一括反映
window.setPremium = function setPremium(enabled){
  const v = !!enabled;
  window.premiumState.value = v;
  try { localStorage.setItem('app.premium', v ? '1' : '0'); } catch {}
  if (window.user) window.user.premium = v;
  try { applyPremiumUI?.(); } catch {}
};

// 既存のユーティリティ（変更なし）
window.isPremium = window.isPremium ?? function(){ return !!window.premiumState?.value; };


 // 一番最初のグローバル定義の近くに追加
// 1) 調整用ユーティリティ（先に読み込む）
window.adjustBottomPadding = function () {
  const tabbar = document.getElementById("tabbar");
  const main   = document.querySelector("main.app-view.is-active");
  if (!tabbar || !main) return;
  const h = tabbar.getBoundingClientRect().height || 0;
  main.style.paddingBottom = `calc(${h}px + env(safe-area-inset-bottom, 0px))`;
};

// 2) CTAの出し分け（無料＆広告レディの時だけ報酬広告ボタン表示）
async function readyRewarded() {
  try { /* SDKのready判定 */ return true; } catch { return false; }
}
async function setupCtas(plan) {
  const rewarded = document.querySelector("#btn-rewarded");
  const adsOK = await readyRewarded();
  if (plan === "free" && adsOK) rewarded.classList.remove("is-hidden");
  else rewarded.remove(); // ← 二重表示の根を断つ

  // ここで addEventListener でハンドラ登録（onclickは使わない）
	document.querySelector("#btn-test")?.addEventListener("click", startTest);
	document.querySelector("#btn-test-vocab")?.addEventListener("click", startVocabularyTest);
	document.querySelector("#btn-swipe")?.addEventListener("click", startSwipeMode);
}

// 3) バナー生成（表示ビューが変わるたびに中身を差し替える）
async function initBanner() {
  const el = document.getElementById("ad-banner");
  if (!el) return;
  el.replaceChildren(); // 既存を空に
  try {
    // 実際のバナーSDKで el に挿入
    // await loadBannerInto(el);
  } catch (e) {
    console.warn("banner init failed", e);
    el.classList.add("fallback");
    el.textContent = "（広告を表示できませんでした）";
  }
}

// 4) 入口例
document.addEventListener("DOMContentLoaded", async () => {
  const plan = window.CURRENT_USER?.plan || "free";
  await setupCtas(plan);

  if (plan === "free") await initBanner();
});

// === 先行プレミアム開放（先行ダウンロード特典） ===
// 期日を過ぎたら自動で元の挙動に戻ります（UTCで指定）
const EARLY_PREMIUM_UNTIL = new Date("2025-11-30T14:59:59Z"); // ←必要に応じて変更

function isEarlyPremiumActive(nowMs = Date.now()) {
  return nowMs <= EARLY_PREMIUM_UNTIL.getTime();
}

// 元の isPremium を保持し、期間中だけ上書き
const _isPremiumBase =
  (typeof window.isPremium === "function" ? window.isPremium.bind(window) : () => false);

window.isPremium = function () {
  if (isEarlyPremiumActive()) return true; // 期間中は全員プレミアム扱い
  return _isPremiumBase();                  // 期間外は従来判定
};


function renderHouseAd(){
  const a=document.createElement('a');
  a.href='https://example.com'; a.target='_blank'; a.rel='noopener';
  a.textContent='🎀 広告：英単語で遊ぼう！タップしてみる';
  Object.assign(a.style,{
    display:'block', width:'100%', textAlign:'center',
    padding:'14px 12px', borderRadius:'10px', background:'#ffe0ef',
    fontWeight:'600'
  });
  return a;
}

function swipeTodayKey(userId){
  const d = new Date();
  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  return `swipeExcluded:${userId}:${ymd}`;
}
	
function mountBanners(){
  const prem = window.isPremium?.() === true;
  document.querySelectorAll('.ad-banner').forEach(el=>{
    el.innerHTML='';
    if (prem){ el.style.display='none'; return; }
    el.style.display='flex';
    el.appendChild(renderHouseAd());
  });
}

document.addEventListener('DOMContentLoaded', mountBanners);
// タブ切替のたびに呼ぶイベントがあるならそれでも呼ぶ
document.addEventListener('viewchange', mountBanners);


async function resolveUserId(){
  const qs = new URLSearchParams(location.search);
  let id = qs.get('userId') || qs.get('id') || localStorage.getItem('userId');
  if (!id) {
    try {
      const r = await fetch('/api/me', {credentials:'include'});
      if (r.ok) {
        const j = await r.json().catch(()=> ({}));
        id = j?.id ?? j?.userId ?? j?.user_id ?? null;
        if (id) localStorage.setItem('userId', String(id));
      }
    } catch {}
  }
  return id ? String(id) : null;
}

(async () => {
  const userId = await resolveUserId();
  if (!userId) { console.warn('userId を取得できません'); return; }

  const part = new URLSearchParams(location.search).get('part') || 'A'; // 必要に応じて
  const res = await fetch(`/api/words?userId=${encodeURIComponent(userId)}&part=${encodeURIComponent(part)}`, {
    credentials: 'include'
  });
  if (!res.ok) { console.error('GET /api/words failed', res.status); return; }
const rows = await res.json();
// TODO: rows を描画 or 正規化
})();

// JSONしか受け付けないfetch（Cookie付き・非JSONは例外）
async function fetchJSON(url, opts = {}) {
  const res = await apiFetch(url, opts);
  const ct = (res.headers.get('content-type') || '').toLowerCase();

  const redirectedToLogin =
    res.redirected && /\/login(?:\.html)?$/.test(new URL(res.url, location.origin).pathname);

  if (redirectedToLogin || res.status === 401 || res.status === 403) {
    const err = new Error('unauthorized'); err.code = 'UNAUTHORIZED'; throw err;
  }

　  // ← ここを追加：204は素通し
  if (res.status === 204) return null;
	
  if (!ct.includes('application/json')) {
    const err = new Error('non-json'); err.code = 'NON_JSON'; err.status = res.status; throw err;
  }
  if (!res.ok) { // ★ 追加：4xx/5xx は例外
    const err = new Error(`bad-status:${res.status}`);
    err.code = 'BAD_STATUS'; err.status = res.status; throw err;
  }
  return res.json();
}


// グローバルで使っているのに未宣言だったので用意
let musouMode = false;
let words = [];
let user = { id: null, premium: false, canWatchVideo: false }; // isPremium 廃止
let currentPage = 1;
const pageSize = 5;
let selectedPart = "part1"; // ← 初期値を設定
let currentPart = 1; // 初期値として Part1 = 1 を設定
const AD_EVERY_TOGGLE = 6;
const AD_EVERY_SWIPE  = 7;
//追加：Part用ページング
let partsPage = 1;
const partsPerPage = 4; // 1ページに出すPart数（お好みで）

const style = document.createElement('style');
style.innerHTML = `
@keyframes pop {
  0% { transform: scale(0.3); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}`;
document.head.appendChild(style);



//表示名と実際のpart名をマッピング
const parts = [
  { label: "Part1", value: "part1" },
  { label: "Part2", value: "part2" },
  { label: "Part3", value: "part3" },
  { label: "Part4", value: "part4" },
  { label: "Part5", value: "part5" },
/*   { label: "Part6", value: "part6" },
  { label: "癒しPart", value: "partHealing" } */
];

document.addEventListener("DOMContentLoaded", initApp);

async function initApp() {
  const ok = await fetchUserInfo();
  if (!ok) {
    // 本当にユーザーIDも無いなら再試行（Renderの起動待ちなど）
    const s = document.getElementById("learningStatus");
    if (s) s.textContent = "サーバ起動中…自動で再試行します";
    setTimeout(initApp, 1200);
    return;
  }

  const urlParams = new URLSearchParams(window.location.search);
  const sessionId = urlParams.get('session_id');
if (sessionId) {
  try {
    const r = await apiFetch(`/api/payment/confirm?session_id=${encodeURIComponent(sessionId)}`);
    const j = await r.json();
    setPremium(!!j.premium);  // ← ここを user.premium = ... ではなく setPremium に
  } catch {}
}

  renderPartButtons();
  await loadWords();
  await refreshUserStats();
  showUpdateInfoIfNeeded();
  ensureHeroVideo();
  placeSwipeBoxAboveStartButton();
  await loadWeeklyAnswers(); 
}

//URLのテスト結果をUIへ反映し、必要ならコミットも打つ
async function applyTestParamsAndCommit() {
  const sp = new URLSearchParams(location.search);
  const from  = sp.get('from');
  const score = parseInt(sp.get('score') || '0', 10);
  const total = parseInt(sp.get('total') || '0', 10);
  const mode  = (sp.get('mode') || 'sentence');
  const userId = getUserIdFromQuery() || 1;

  if (from !== 'test' || !total) return;

  // ★ この結果はもう処理済み？
  const resultKey = `testResultHandled:${userId}:${mode}:${score}/${total}`;
  if (sessionStorage.getItem(resultKey) === '1') {
    // 既に処理済みならクエリだけ消しておく
    history.replaceState(null, '', location.pathname + location.hash);
    return;
  }

  // 画面に即時反映
  const ts = document.getElementById("testStats");
　if (ts) ts.textContent = `正答数: ${score} / ${total}問中`;

  // ローカル加算（今回が未処理のときだけ）
  const localTotalCorrectKey = `localTotalCorrect:${userId}`;
  const prevLocal = parseInt(localStorage.getItem(localTotalCorrectKey) || '0', 10);
  const newLocal  = prevLocal + score;
  localStorage.setItem(localTotalCorrectKey, String(newLocal));

  // レベル演出（差分分だけ）
  const prevLevel = Math.floor(prevLocal / 10);
  const newLevel  = Math.floor(newLocal / 10);
  for (let lv = prevLevel + 1; lv <= newLevel; lv++) showLevelUpPopup(lv);

  // サーバへコミット（未コミット時のみ）
  const committedKey = `committed:${userId}:${mode}:${score}/${total}`;
  if (!sessionStorage.getItem(committedKey)) {
    try {
      const res = await apiFetch('/api/test/commit', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ mode, correct: score, total })
      });
      if (res.ok) sessionStorage.setItem(committedKey, '1');
    } catch (e) { console.warn('commit failed', e); }
  }

  // ★ 二重起動防止フラグを立て、URLのクエリを除去
  sessionStorage.setItem(resultKey, '1');
  history.replaceState(null, '', location.pathname + location.hash);
}

// 既存の DOMContentLoaded 後や loadWords() 完了後に呼んでOK
document.addEventListener('DOMContentLoaded', () => {
　applyTestParamsAndCommit();
　document.getElementById('watchAdBtn')?.addEventListener('click', handleAdAccept);
　document.getElementById('cancelAdBtn')?.addEventListener('click', closeAdModal);

});


//✅ アップデート履歴（例）
const latestUpdateVersion = "1.3.0"; // ← 最新バージョン
const updateMessage = `
  <ul style="text-align: left;">
    <li>🎉 新機能「衣装切り替え」ボタンを追加</li>
    <li>📈 正答数に応じたレベルアップ演出を追加</li>
    <li>🔒 無料ユーザーには一部機能にプレミアム制限</li>
    <li>🐞 軽微なバグ修正とUI改善</li>
  </ul>
`;

// 置き換え
async function headOk(u){
  try{
    const sameOrigin = (() => {
		try { return new URL(u, location.origin).origin === location.origin; }
		catch { return false; }
	})();
    const opt1 = { method: 'HEAD', cache: 'no-store', ...(sameOrigin ? {credentials:'include'} : {}) };
    const r = await fetch(u, opt1);
    if (!r.ok) {
      const opt2 = { method: 'GET', cache: 'no-store', ...(sameOrigin ? {credentials:'include'} : {}) };
      const g = await fetch(u, opt2);
      return g.ok;
    }
    return true;
  }catch{ return false; }
}

async function pickFirstAvailable(list){
  for (const u of list){
    if (await headOk(u)) return u;
  }
  return null;
}

async function ensureHeroVideo(){
  const v = document.getElementById('girlVideo');
  if (!v) return;

const prefer = window.isPremium() ? ['/videos/run_girl_motion.mp4'] : [];
const candidates = [
  ...prefer,
  '/videos/girl_idle_loop.mp4',
  'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/videos/girl_idle_loop.mp4'
];

  const ok = await pickFirstAvailable(candidates);
  if (ok){
    v.src = ok;
    try { await v.play(); } catch {}
  }else{
    const p = v.parentElement;
    v.remove();
    const img = document.createElement('img');
    img.src = '/images/beauty.png';
    img.alt = 'girl';
    img.style.borderRadius = '10px';
    img.width = 180;
    p.appendChild(img);
  }
}

// --- 残留モーダル掃除（任意） ---
function cleanupSwalOverlay(){
  document.querySelectorAll('.swal2-container').forEach(el => el.remove());
  document.body.style.pointerEvents = 'auto';
}

/**
 * ボタン初期化本体。引数でハンドラを受け取るので、外の定義順に依存しない。
 */
function setupCtas(handlers) {
  cleanupSwalOverlay();

  const defs = [
    { sel:'#startTestBtn',     on:handlers.onStartTest,  label:'テストを開始する' },
    { sel:'#startWordModeBtn', on:handlers.onStartWord,  label:'テストを開始する(単語モード)' },
    { sel:'#startSwipeBtn',    on:handlers.onStartSwipe, label:'スワイプ学習を始める' },
    { sel:'#adBeautyBtn',      on:handlers.onWatchAd,    label:'広告を見て美女で英単語を表現' }, // 無ければスキップ
  ];

  for (const it of defs) {
    const el = document.querySelector(it.sel);
    if (!el) { console.warn('[setupCtas] missing', it.sel); continue; }

    try {
      const clone = el.cloneNode(true);     // 重複リスナ対策
      el.replaceWith(clone);

      clone.disabled = false;
      clone.classList?.remove('is-loading');
      if (!clone.dataset.labelApplied) {
        clone.textContent = it.label;
        clone.dataset.labelApplied = '1';
      }

      const handler = async (e) => {
        e.preventDefault();
        if (clone.disabled) return;
        clone.disabled = true;
        try { await it.on?.(); }
        catch (err) {
          console.error(`[handler error] ${it.sel}`, err);
          alert('読み込みに失敗しました。もう一度お試しください。');
        } finally {
          clone.disabled = false; // 遷移する場合は戻らないので影響なし
        }
      };

      clone.addEventListener('click', handler, { passive:false });
    } catch (e) {
      console.error('[setupCtas] init error', it.sel, e);
    }
  }
}

/**
 * ハンドラ（startTest 等）がロードされるまで待ってから setupCtas を呼ぶ。
 * 最大5秒リトライ（100ms刻み）。
 */
function bindCtasWhenReady(tries = 0) {
  const ok =
    typeof window.startTest === 'function' &&
    typeof window.startVocabularyTest === 'function' &&
    typeof window.startSwipeMode === 'function';

  if (!ok) {
    if (tries < 50) return setTimeout(() => bindCtasWhenReady(tries + 1), 100);
    console.warn('[setupCtas] handlers not ready, skip binding');
    return;
  }

  const handlers = {
    onStartTest : async () => { await window.startTest(); },
    onStartWord : async () => { await window.startVocabularyTest(); },
    onStartSwipe: async () => { await window.startSwipeMode(); },
    onWatchAd   : async () => { try { await window.showAd?.(); } catch(e){ console.error(e); } },
  };

  setupCtas(handlers);
}

document.addEventListener('DOMContentLoaded', () => {
  try { bindCtasWhenReady(); } catch (e) { console.error(e); }
});
	
</script>

<script>
function qBtnByLabel(label){
  return [...document.querySelectorAll('button, a[role="button"]')]
    .find(b => (b.textContent || '').trim().replace(/\s+/g,'') === label);
}

function setupCtasByText(){
  const pairs = [
    { node:qBtnByLabel('テストを開始する'),             on:onStartTest },
    { node:qBtnByLabel('テストを開始する(単語モード)'), on:onStartWord },
    { node:qBtnByLabel('スワイプ学習を始める'),         on:onStartSwipe },
    { node:qBtnByLabel('広告を見て美女で英単語を表現'),   on:onWatchAd },
  ];
  for (const p of pairs) {
    if (!p.node) continue;
    const c = p.node.cloneNode(true);
    p.node.replaceWith(c);
    c.addEventListener('click', (e)=>{ e.preventDefault(); try{p.on?.();}catch(e){console.error(e);} });
  }
}
document.addEventListener('DOMContentLoaded', () => {
  setupCtasByText();
});
// DOM 準備できたら実行（例外で止まらないよう try）
document.addEventListener('DOMContentLoaded', () => {
  try { setupCtas(); } catch(e){ console.error(e); }
  // 広告／ブリッジ準備までボタンを一時無効化したい場合はここで制御
});

  // ★ タブ起動時点で未定義エラーを防ぐためのプレースホルダ
 // 置き換え
	addEventListener("resize", () => window.adjustBottomPadding && window.adjustBottomPadding());
	document.addEventListener("DOMContentLoaded", () => window.adjustBottomPadding && window.adjustBottomPadding());


    /* ===== 下タブ切替 ===== */
    (function(){
      const views = {
        home:  document.getElementById('view-home'),
        test:  document.getElementById('view-test'),
        words: document.getElementById('view-words')
      };
      const tabbar = document.getElementById('tabbar');
      const tabs = Array.from(tabbar.querySelectorAll('.tab'));

    function activate(tab){
	  localStorage.setItem('activeTab', tab);
	  Object.values(views).forEach(v => v.classList.remove('is-active'));
	  views[tab]?.classList.add('is-active');
	
	  tabs.forEach(b => {
	    const on = b.dataset.tab === tab;
	    b.classList.toggle('is-active', on);
	    b.setAttribute('aria-selected', on ? 'true' : 'false');
	  });
	
	  // ここを安全呼び出しに
	  if (typeof window.adjustBottomPadding === 'function') {
	    window.adjustBottomPadding();
	  }
	}


      tabbar.addEventListener('click', (e)=>{
        const btn = e.target.closest('.tab');
        if (!btn) return;
        const tab = btn.dataset.tab;
        if (tab) activate(tab);
      });

      const ini = localStorage.getItem('activeTab') || 'home';
      activate(ini);

      // 外から呼べるように
      window.switchTab = activate;
    })();

    /* ===== AdMobバナーの下余白（adSpacer）を調整 ===== */
    (function(){
  const adSpacer = document.getElementById('adSpacer');
  const tabbar   = document.getElementById('tabbar');

  let bannerHeight = 50;       // デフォルト推定（SDKから上書き）
  const TABBAR_H   = 56;

  function applyPadding(){
    // 1) バナーの下余白（Web側の疑似スペーサ）
    adSpacer.style.height = (bannerHeight) + 'px';

    // 2) アクティブビューの下パディング（tabbar + バナー + セーフエリア）
    document.querySelectorAll('.app-view.is-active').forEach(v=>{
      v.style.paddingBottom = `calc(${TABBAR_H + bannerHeight}px + env(safe-area-inset-bottom))`;
    });

    // 3) tabbar 自体をバナー高さだけ持ち上げる（= バナーの上に出す）
    if (tabbar){
      tabbar.style.bottom = `calc(${bannerHeight}px + env(safe-area-inset-bottom))`;
    }
  }

  // 他の場所で使うために公開しておく（あなたの既存と合わせる）
  window.adjustBottomPadding = applyPadding;
  applyPadding();

  // Capacitor AdMob から実際の高さが届いたら更新
  
  if (window.AdMob?.addListener){
    try {
      window.AdMob.addListener('onAdLoaded', (ev) => {
        if (Number(ev?.height)) {
          bannerHeight = Number(ev.height);
          applyPadding();
        }
      });
    } catch(e){}
  }

  // 念のため遅延でもう一度
  setTimeout(applyPadding, 300);
})();

	// 追加（どこでもOK、updateLoginPointsIfNeeded より上でも下でも）
function setLoginDays(points){
  const el = document.getElementById('loginDays');
  if (el) el.textContent = `学習日数: ${points}日目`;
}

// UIだけ反映（フラグは変更しない）
// 旧: function markPremiumEnabled(){ ... user.premium = true; ... }
function applyPremiumUI() {
  try {
    // 表示だけ更新（フラグは window.isPremium()/premiumState を参照）
    const planEl = document.getElementById("planText");
    if (planEl) planEl.innerText = `プラン: ${window.isPremium() ? "プレミアム" : "無料"}`;

    ensureHeroVideo?.();
    updateCounter?.('soft');
    refreshUserStats?.();

    // 広告非表示など（存在すれば）
    hideNativeBannerIfPossible?.();
    window.adjustBottomPadding?.();
	mountBanners?.();
  } catch (e) {
    console.warn('applyPremiumUI error:', e);
  }
}

// 2) ネイティブから最新状態を取得（起動時/ログイン後に1回）
async function refreshPremium() {
  if (!NativePremium) return window.isPremium();
  try {
    const { value } = await NativePremium.isPremium();
    setPremium(!!value);
  } catch { /* 現状維持 */ }
  return window.isPremium();
}

// 3) 購入
async function purchasePremium() {
  if (!NativePremium) { alert('この環境では購入できません（ネイティブ専用）'); return false; }
  try {
    const { success } = await NativePremium.purchase();
    if (success === true) {
      setPremium(true); // ← これだけ
      try { await setUserPremium(getUserId()); } catch {}
      try { await hideNativeBannerIfPossible(); } catch {}
      window.adjustBottomPadding?.();
      try { await refreshUserStats?.(); } catch {}
    }
    return !!success;
  } catch (e) {
    console.warn('purchase failed', e);
    alert('購入に失敗しました。時間をおいてお試しください。');
    return false;
  }
}

async function restorePurchase() {
  if (!NativePremium) return false;
  try {
    const { success } = await NativePremium.restore();
    if (success) {
      setPremium(true); // ← これだけ
      try { await setUserPremium(getUserId()); } catch {}
      try { await hideNativeBannerIfPossible(); } catch {}
      window.adjustBottomPadding?.();
    }
    return !!success;
  } catch (e) {
    console.warn('restore failed', e);
    return false;
  }
}

// 5) 起動時に最新状態へ（← async を付ける）
document.addEventListener('DOMContentLoaded', async () => {
  await refreshPremium();
  applyPremiumUI();
});
/* ========= StoreKit bridge (Web <-> iOS) =========
 * - iOSアプリの WKWebView に載せたときは window.webkit.messageHandlers.storekit が使えます
 * - ブラウザでは存在しないので自動でフォールバックします（従来の広告/Stripeのフロー）
 */
const SK_PRODUCT_ID = "premium_unlock_300";  // App Store Connect で作成した商品IDに置き換え

// iOS(WKWebView)判定
function isIOSApp() {
  return !!(window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.storekit);
}

// JS -> iOS (StoreKit) へメッセージ
function skPost(action, payload = {}) {
  if (!isIOSApp()) return false;
  window.webkit.messageHandlers.storekit.postMessage({ action, ...payload });
  return true;
}

// iOS -> JS コールバック
window.onStoreKitMessage = function (msg) {
  try {
	// entitlements は “購入済みかの照会” だけ。true/false をそのまま信じない。
	if (msg.event === 'entitlements') {
	  if (msg && msg.premium === true) {
	    setPremium(true);
		} else {
		  // 未購入ならここでは何もしない（purchase を待つ）
		  console.log('[SK] entitlements: not premium');
		  }
		return;
	}
    if (msg.event === 'purchased' || msg.event === 'restored') {
      setPremium(true);
      Swal.fire({icon:'success', title:'プレミアムを解放しました！'});
      return;
    }
    if (msg.event === 'failed') {
      Swal.fire({icon:'error', title:'購入に失敗しました', text: msg.error || 'キャンセル/失敗'});
      return;
    }
    if (msg.event === 'deferred') {
      Swal.fire({icon:'info', title:'承認待ち', text:'ファミリー承認待ちなどで保留になりました。'});
    }
  } catch (e) { console.warn(e); }
};


// ===== モーダルのボタンの配線（既存IDを流用） =====
(function wireAdModalToStoreKit(){
  const watchBtn  = document.getElementById('watchAdBtn');
  const cancelBtn = document.getElementById('cancelAdBtn');

  if (!watchBtn || !cancelBtn) return;

  cancelBtn.addEventListener('click', () => {
    // 従来の広告モーダルを閉じるだけ
    closeAdModal();
  });

  watchBtn.addEventListener('click', async () => {
    // iOSアプリ内なら StoreKit を起動、ブラウザなら従来のフロー
    if (isIOSApp()) {
      closeAdModal();
      // 1) 現在の権利チェック（すでに購入済みなら即反映）
      skPost('checkEntitlements');
      // 2) 未購入なら購入シート表示
      skPost('purchase', { productId: SK_PRODUCT_ID });
    } else {
      // ブラウザ/PWAでは従来どおりの処理（広告 or Stripe）
      handleAdAccept();    // ← あなたの既存関数（広告→6枚付与）
      // あるいは Stripe へ誘導するなら: showPremiumPopup();
    }
  });

  // 任意：JSから復元を出したい場合の例
  window.restorePremium = function(){
    if (isIOSApp()) skPost('restore');
    else Swal.fire({icon:'info', text:'アプリ内で復元を実行してください。'});
  };

  // 読み込み時に一度だけ権利確認（アプリ内）
  if (isIOSApp()) skPost('checkEntitlements');
})();

// ✅ 初回ログイン or バージョン変更時のみ表示
// v1.1: 事故防止つきアップデート情報モーダル
function showUpdateInfoIfNeeded() {
  const key = "updateInfoShownVersion";
  const shownVersion = (() => {
    try { return localStorage.getItem(key); } catch (e) { return null; }
  })();

  if (shownVersion === latestUpdateVersion) return;

  // DOMに残ったオーバーレイ等を確実に除去する保険
  const cleanupOverlays = () => {
    document.querySelectorAll(".swal2-container").forEach(el => el.remove());
    // まれに body のヒットテストが奪われる事故対策
    document.body.style.pointerEvents = "auto";
  };

  let failSafeTimer;

  Swal.fire({
    title: `✨アップデート情報 (v${latestUpdateVersion})✨`,
    html: updateMessage,
    icon: "info",
    confirmButtonText: "閉じる",
    confirmButtonColor: "#e91e63",

    // ★ 閉じられる導線を増やす
    allowOutsideClick: true,     // 背景タップで閉じる
    allowEscapeKey: true,        // ESCで閉じる
    heightAuto: false,           // iOS のレイアウト崩れ回避

    didOpen: () => {
      // ★ 10秒フェイルセーフ自動クローズ（レビュアー保護）
      failSafeTimer = setTimeout(() => {
        if (Swal.isVisible()) Swal.close();
      }, 10000);
    },
    willClose: () => {
      clearTimeout(failSafeTimer);
    }
  })
  .then(() => {
    // ★ 閉じられた“後で”既読化（閉じられないまま既読にしない）
    try { localStorage.setItem(key, latestUpdateVersion); } catch (e) {}
    // ★ 残留オーバーレイの完全除去
    setTimeout(cleanupOverlays, 0);
  })
  .catch(() => {
    // 例外時もオーバーレイを残さない
    setTimeout(cleanupOverlays, 0);
  });

  // ★ 二重保険：予想外の状態でも12秒後に強制クローズ＋掃除
  setTimeout(() => {
    if (document.querySelector(".swal2-container")) {
      try { Swal.close(); } catch (e) {}
      setTimeout(cleanupOverlays, 0);
    }
  }, 12000);
}
	
async function checkPremiumStatus(userId) {
	  try {
			const res = await apiFetch(`/user/${encodeURIComponent(userId)}`);
		  	const ct = res.headers.get('content-type') || '';
		    if (!res.ok || !ct.includes('application/json')) return;
	    	const u = await res.json();
	    if (u.premium === true) {
	      // 既存の girlVideo を使用し、存在しない場合はフォールバック
	      const v = document.getElementById("girlVideo");
	      if (v) {
	        const prefer = "/videos/run_girl_motion.mp4";
	        const fallback = "/videos/girl_idle_loop.mp4";
	        v.onerror = () => { v.src = fallback; };
	        v.src = prefer;
	      }
	    }
	  } catch (err) {
	    console.error("ユーザー情報の取得に失敗", err);
	  }
	}

function placeSwipeBoxAboveStartButton(){
  const box = document.getElementById('swipeModeBox');
  const btn = document.getElementById('swipeStartBtn');
  if (!box || !btn) return;
  const wrap = btn.parentElement;                 // ボタンを包む <div ...>
  if (wrap && box.previousElementSibling !== wrap){
    // ボタンの“直前”に #swipeModeBox を移動
    wrap.parentNode.insertBefore(box, wrap);
  }
}
// changePart は selectedPart のみ更新でOK
function changePart(partName) {
  selectedPart = partName;
  const isMusou = (partName === '無双Part');
  musouMode = isMusou;
  if (isMusou) {
    goToPart(undefined, "無双Part");
  } else {
    loadWords();
  }
}


const CDN_BASE = 'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/images';
// 単語からファイル名用スラッグ
function toSlugForImage(s) {
  return (s || "")
    .toLowerCase()
    .trim()
    .replace(/['’`"]/g, "")
    .replace(/\s+/g, "_")
    .replace(/[^a-z0-9_]/g, "");
}

// API 1件をフロントで共通形に正規化
function normalizeWord(raw) {
  const w = {
    id: raw.id ?? raw.wordId ?? raw.word_id ?? raw._id ?? null,   // ← 追加
    word: raw.word ?? "",
    meaning: raw.meaning ?? "",
    part: (raw.part ?? "").toLowerCase(),
    pictUrl: raw.pict_url ?? raw.pictUrl ?? "",
    pictUrlStatic: raw.pict_url_static ?? raw.pictUrlStatic ?? "",
    pictUrlAnimated: raw.pict_url_animated ?? raw.pictUrlAnimated ?? "",
    audioUrl: raw.audio_url ?? raw.audioUrl ?? "",
    videoUrl: raw.video_url ?? raw.videoUrl ?? "",
    status: !!(raw.status ?? raw.learned ?? false),
  };
  w.imageUrl = imageUrlForWord(w);
  return w;
}

// 単語オブジェクトから画像URLを決定（優先順）
function imageUrlForWord(w) {
  return (
    w.pictUrl ||
    w.pictUrlStatic ||
    w.pictUrlAnimated ||
    `/images/${toSlugForImage(w.word)}_girl.png`
  );
}

// 画像404時のフォールバック
function imgTag(src, alt = "") {
  return `<img src="${safeSrc(src,{allowDataImage:true})}" alt="${escHTML(alt)}"
           width="88" height="132" loading="lazy" decoding="async"
           style="object-fit:cover;border-radius:8px"
           onerror="this.onerror=null;this.src='/images/beauty.png'">`;
}

// ▼ 使い方例：取得後に正規化
// const rows = await (await fetch(`/api/words?userId=${uid}&part=part1`)).json();
// const words = rows.map(normalizeWord);

async function uploadAndNormalize(file, mode = "cover") {
  const form = new FormData();
  form.append("file", file);
  const res = await apiFetch(`/api/images/normalize/${mode}`, { method: "POST", body: form });
  if (!res.ok) throw new Error("画像の正規化に失敗");
  return await res.json(); // { url, width, height, mode }
}

async function onFileChange(e, currentWord) {
  const file = e.target.files?.[0];
  if (!file) return;
  const { url } = await uploadAndNormalize(file, "cover");
  // 例：保存APIに反映（実装に合わせて）
  // await fetch(`/api/words/${currentWord.id}`, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ pict_url: url }) });
  currentWord.pictUrl = url;
  currentWord.imageUrl = imageUrlForWord(currentWord);
  // 再描画処理…
}

// userId は一切使わず、セッションで本人認可
// 互換のため第1引数は未使用
function goToPart(_unused, partName) {
  const locked = ["無双Part", "part4", "part5", "part6", "partHealing", "musou"];
  if (!window.isPremium?.() && locked.includes(partName) && !isAdEnabled()) {
    Swal.fire({
      title: "このパートは広告視聴が必要です",
      html: `<p>広告を見れば<strong>残り6枚めくれます</strong>。<br>
             <span style="color:#e91e63;font-weight:bold;">🎀プレミアム</span>なら<strong>無制限で開放</strong>！</p>`,
      icon: "info",
      showCancelButton: true,
      showDenyButton: true,
      confirmButtonText: "広告を見る",
      cancelButtonText: "やめる",
      denyButtonText: "🎀 プレミアムへ"
    }).then(result => {
      if (result.isConfirmed) {
        // ✅ 広告成功後に遷移
        pendingToggle = () => { location.href = `musou.html?part=${encodeURIComponent(partName)}`; };
        showAd();
      } else if (result.isDenied) {
        window.showPremiumPopup?.();
      }
    });
    return;
  }
  // 開放済みなら即遷移
  location.href = `musou.html?part=${encodeURIComponent(partName)}`;
}

function playAll(wordText) {
  const item = words.find(w => w.word === wordText);
  if (item?.videoUrl) {
    playVideo(item.videoUrl);
  } else {
    Swal.fire({ icon: 'info', text: 'この単語の動画がありません' });
  }
}


function renderWordCard(word, musouMode, user) {
  if (musouMode) {
    return `
      <div class="musou-card">
        <h3>${word.word}（${word.meaning}）</h3>
        ${word.audioUrl ? `<audio controls src="${word.audioUrl}"></audio>` : ""}
        ${word.videoUrl ? `<video controls width="200" src="${word.videoUrl}"></video>` : ""}
        ${imgTag(word.imageUrl, word.word)}
        <button onclick="${window.isPremium() ? `playAll('${word.word}')` : 'showPremiumPopup()'}">美女を動かす</button>
      </div>`;
  } else {
    return `
      <div class="normal-card">
        <strong>${word.word}（${word.meaning}）</strong><br>
        ステータス: <input type="checkbox" ${word.status ? "checked" : ""}>
        <br>
        ${imgTag(word.imageUrl, word.word)}
        <br>
        <button onclick="${window.isPremium() ? `playVideo('${esc(String(word.videoUrl||''))}')` : 'showPremiumPopup()'}">美女を動かす</button>
      </div>`;
  }
}
// ▼ここ差し替え：6枚方式の状態管理
let remainingCards = Number(localStorage.getItem('remainingCards') || 0);

function consumeOne(){
  if (window.isPremium()) return true;           // プレミアムは消費しない
  if (remainingCards <= 0){ showAd(); return false; }
  remainingCards = Math.max(0, remainingCards - 1);
  saveRemaining();
  updateCounter('soft');
  return true;
}

function watchAdGlobal(){
  // 5分解放は廃止。通常のリワード広告→6枚付与だけ。
  showAd();  // showAd() の成功コールバックで onAdWatchedSuccess() が呼ばれる想定
}


function saveRemaining() {
  localStorage.setItem('remainingCards', String(remainingCards));
}

// バッジ表示の切替＆演出
// 追加：一覧のバッジ（remaining-inline）をまとめて更新
function updateRemainingInline(){
  const nodes = document.querySelectorAll('.remaining-inline');
  nodes.forEach(el => {
    if (window.isPremium()){
      el.textContent = '無制限';
      el.classList.add('is-premium');
    } else {
      el.classList.remove('is-premium');
      el.textContent = (remainingCards > 0) ? `残り ${remainingCards} 枚` : '広告で +6 枚';
    }
  });
}

// 置き換え：updateCounter（最初に inline を更新してから従来のバッジも更新）
function updateCounter(effect='none'){
  // ← 一覧側のピル
  updateRemainingInline();

  // ← 既存の右上バッジ（#cardCounter）は残っていてもOK / 無ければスキップ
  const badge = document.getElementById('cardCounter');
  if (badge){
    if (window.isPremium()){
      badge.textContent = '無制限';
      badge.onclick = null;
      badge.style.opacity = '1';
    } else if (remainingCards > 0){
      badge.textContent = `残り ${remainingCards} 枚`;
      badge.onclick = null;
      badge.style.opacity = '1';
    } else {
      badge.textContent = '広告を見て再開！';
      badge.onclick = () => showAd();
      badge.style.opacity = '.95';
    }
    badge.classList.remove('pop-glow','pop-soft');
    void badge.offsetWidth;
    if (effect === 'glow') badge.classList.add('pop-glow');
    if (effect === 'soft') badge.classList.add('pop-soft');
  }
}



document.addEventListener('DOMContentLoaded', () => updateCounter('none'));

// ▼ここ差し替え：カードをめくる前に残枚数チェック
function flipCard() {
  if (remainingCards <= 0) {
    // 0枚時は広告へ誘導（バッジも“広告を見て再開！”表示済）
    showAd();
    return;
  }
  // 正常：次カード表示 → 残枚数を1減らす
  showNextCard();           // ← 既存のカード表示処理を呼ぶ
  remainingCards--;
  saveRemaining();
  updateCounter('soft');    // 軽いポン演出
}

// ▼ここ差し替え：広告表示（Capacitor + AdMob ラッパー対応）
async function showAd() {
  // AdMobプラグインが存在しない（ブラウザなど）場合は confirm フォールバック
  if (!window.AdMob) {
    const ok = confirm('【デモ】広告を最後まで視聴しましたか？\nOK=成功 / Cancel=キャンセル');
    if (ok) onAdWatchedSuccess(); else onAdClosedOrFailed();
    return;
  }

  try {
    // === AdMob初期化（まだなら一度だけ） ===
    await window.AdMob.initialize({
      requestTrackingAuthorization: true,
      initializeForTesting: false, // ← テスト時は true
    });

    // === リワード広告を準備 ===
    await window.AdMob.prepareRewardVideoAd({
      adId: 'ca-app-pub-3517487281025314/1240830098', // ← ご自身のリワード広告IDに差し替え
      isTesting: false // ← テスト時は true
    });

    // === 表示 + コールバック処理 ===
    await window.AdMob.showRewardVideoAd({
      onRewarded: () => {
        console.log('✅ onRewarded: 報酬付与');
        onAdWatchedSuccess();
      },
      onDismissed: () => {
        console.log('🟡 onDismissed: 閉じる or スキップ');
        onAdClosedOrFailed();
      },
      onError: (e) => {
        console.error('❌ onError', e);
        onAdClosedOrFailed(e);
      }
    });

  } catch (e) {
    console.error('AdMob showAd error:', e);
    // ネイティブで失敗した場合は confirm フォールバック
    const ok = confirm('【デモ】広告を最後まで視聴しましたか？\nOK=成功 / Cancel=キャンセル');
    if (ok) onAdWatchedSuccess(); else onAdClosedOrFailed();
  }
}

// ▼ここ差し替え：広告“成功時のみ”6枚付与（バグの根本対策）
function onAdWatchedSuccess(){
  remainingCards = 6;
  saveRemaining();
  resetBeautyClickCount();
  updateCounter('glow');

  if (typeof pendingToggle === 'function'){
    const cb = pendingToggle; pendingToggle = null;
    try { cb(); } catch {}
  }
}


// ▼ここ差し替え：キャンセル/失敗は何もしない（追加付与しない！）
function onAdClosedOrFailed(err) {
  // ログだけ（必要なら）
  if (err) console.warn('Ad closed/failed:', err);
  // 付与しない・残枚数も変えない
  updateCounter('none');
}

// ▼ここ差し替え：カードDOM生成時にURLがテキストで出ないようにする
// 既存の showNextCard() 内で「テキストにURLを流し込む」のをやめ、必ず <img> をappend する
function createWordCard({ imageUrl, alt = 'word' }) {
  const card = document.createElement('div');
  card.style.width = '100%';
  card.style.height = '100%';
  card.style.display = 'flex';
  card.style.alignItems = 'center';
  card.style.justifyContent = 'center';
  card.style.background = '#fff';

  const img = document.createElement('img');
　img.src = safeSrc(imageUrl, { allowDataImage: true });
  img.onerror = () => { img.src = '/images/beauty.png'; };
  img.alt = alt;
  img.style.maxWidth = '100%';
  img.style.maxHeight = '100%';
  img.style.objectFit = 'contain';

  // ここで絶対に URL を textContent/innerText に入れない！
  // card.textContent = imageUrl; ← NG（これが“URLが表示される”原因）

  card.appendChild(img);
  return card;
}

// 例：既存処理の一部イメージ
function showNextCard() {
  const area = document.getElementById('cardArea');
  if (!area) return;
  area.innerHTML = '';

  // 次カード情報を取得（既存ロジックに合わせて）
  const next = getNextWordCardInfo(); // { imageUrl, alt }
  area.appendChild(createWordCard(next));
}

// ▼ここ差し替え：無双Partは出さない（フラグで抑止）
const MUSOU_ENABLED = false;
window.addEventListener('DOMContentLoaded', () => {
　document.getElementById('watchAdBtn')?.addEventListener('click', handleAdAccept);
  document.getElementById('cancelAdBtn')?.addEventListener('click', closeAdModal);
  if (!MUSOU_ENABLED) {
    const musouNav = document.getElementById('nav-muso'); // メニュー項目などに付与してあるIDを指定
    if (musouNav) musouNav.style.display = 'none';
  }
});

function getUserId(){
  // ← クエリ(userId)最優先で取得する
  return getUserIdFromQuery() || user?.id || localStorage.getItem("userId") || "1";
}

function showLevelUpPopup(newLevel) {
	  const title = getTitleByLevel(newLevel);
	  Swal.fire({
	    title: '🎉 LEVEL UP！🎉',
	    html: `
	      <p style="font-size: 20px;">新しいレベル: Lv.${newLevel}</p>
	      <div style="margin-top: 10px;">称号：<strong>${title}</strong></div>
	      <div class="slide-message" style="font-size: 18px; margin-top: 10px;">この調子で頑張ろう！</div>
	      <br>
	      <button id="shareButton" style="background:#1da1f2;color:white;padding:8px 12px;border:none;border-radius:5px;cursor:pointer;">
	        SNSでシェアする
	      </button>
	    `,
	    showConfirmButton: false,
	    timer: 6000,
	    didOpen: () => {
	      document.getElementById("shareButton").addEventListener("click", () => {
	        const shareText = `私は今レベル${newLevel}で「${title}」に到達しました！ #美女単`;
	        const shareUrl = encodeURIComponent("https://your-app-url.com");
	        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${shareUrl}`;
	       	window.open(tweetUrl, '_blank', 'noopener,noreferrer');
	      });
	    }
	  });
	}

// 置き換え：ボタンの描画（ページ内のPartだけ表示）
function renderPartButtons() {
  const container = document.getElementById("partButtons");
　if (!container) return;
  container.innerHTML = "";

  const start = (partsPage - 1) * partsPerPage;
  const view = parts.slice(start, start + partsPerPage);

  view.forEach(({ label, value }) => {
    const btn = document.createElement("button");
    btn.textContent = label;
    btn.onclick = () => selectPart(value);
    if (value === selectedPart) btn.style.fontWeight = "bold";
    container.appendChild(btn);
  });

  renderPartPagination(); // ← ページ番号も更新
}

function renderPartPagination() {
  const pageCount = Math.ceil(parts.length / partsPerPage);
  const bottom = document.getElementById("partPagination");
  const containers = [bottom].filter(Boolean); // ← 上は使わない

  containers.forEach(c => { c.innerHTML = ""; });
  if (pageCount <= 1) {
    containers.forEach(c => c.classList.add("hidden"));
    return;
  }
  containers.forEach(c => c.classList.remove("hidden"));

  const build = (wrap) => {
const makeBtn = (label, page, disabled = false, active = false) => {
  const btn = document.createElement("button");
  btn.type = "button";
  btn.textContent = label;
  btn.setAttribute(
    "aria-label",
    label === "‹" ? "前のページ" :
    label === "›" ? "次のページ" :
    `ページ ${label}`
  );
  if (disabled) btn.disabled = true;
  if (active) { btn.classList.add("active"); btn.setAttribute("aria-current","page"); }
      btn.addEventListener("click", () => {
        if (disabled || !page || page === partsPage) return;
        const oldTop = wrap.getBoundingClientRect().top;
        partsPage = page;
        renderPartButtons();
        requestAnimationFrame(() => {
          const newTop = wrap.getBoundingClientRect().top;
          window.scrollBy(0, newTop - oldTop);
        });
      });
      return btn;
    };
    const addPage = (n) => wrap.appendChild(makeBtn(String(n), n, false, n === partsPage));
    const addDots = () => { const s=document.createElement("span"); s.className="ellipsis"; s.textContent="…"; wrap.appendChild(s); };

    wrap.appendChild(makeBtn("‹", partsPage - 1, partsPage === 1));
    if (pageCount <= 5) for (let i=1;i<=pageCount;i++) addPage(i);
    else if (partsPage <= 3){ addPage(1);addPage(2);addPage(3);addDots();addPage(pageCount); }
    else if (partsPage >= pageCount-2){ addPage(1);addDots();addPage(pageCount-2);addPage(pageCount-1);addPage(pageCount); }
    else { addPage(1);addDots();addPage(partsPage-1);addPage(partsPage);addPage(partsPage+1);addDots();addPage(pageCount); }
    wrap.appendChild(makeBtn("›", partsPage + 1, partsPage === pageCount));
  };

  containers.forEach(build);
}

// 修正：Part選択時に「そのPartが載っているページ」を自動表示
// 修正：Part選択時に「そのPartが載っているページ」を自動表示
function selectPart(part) {
  const lockedParts = ["part4", "part5", "part6", "partHealing", "musou"];
  const isLockedPart = lockedParts.includes(part);

  const show = () => {
    // 対象Partが含まれるページを自動で表示
    selectedPart = part;
    const idx = Math.max(0, parts.findIndex(p => p.value === part));
    partsPage   = Math.floor(idx / partsPerPage) + 1;
    currentPart = idx + 1;
    currentPage = 1;
    renderPartButtons?.();
    loadWords?.();
  };

  const premium = typeof window.isPremium === 'function' ? window.isPremium() : false;
  const adOpen  = typeof window.isAdEnabled === 'function' ? window.isAdEnabled() : false;

  if (!premium && isLockedPart && !adOpen) {
    Swal.fire({
      title: "このパートは広告視聴が必要です",
      html: `<p>広告を見れば<strong>残り6枚めくれます</strong>。<br>
             <span style="color:#e91e63;font-weight:bold;">🎀プレミアム会員</span>なら、<strong>無制限で開放</strong>されます。</p>`,
      icon: "info",
      showCancelButton: true,
      showDenyButton: true,
      confirmButtonText: "広告を見る",
      cancelButtonText: "やめる",
      denyButtonText: "🎀 300円で広告なし！美女めくり放題🎀"
    }).then(result => {
      if (result.isConfirmed) {
        // ✅ 広告視聴に成功したら show() を実行
        window.setAdPendingToggle?.(show);
        window.showAd?.();
      } else if (result.isDenied) {
        window.showPremiumPopup?.();
      }
    });
  } else {
    show();
  }
}

// クエリから userId を取る小道具
function getUserIdFromQuery() {
  const p = new URLSearchParams(location.search);
  return p.get('userId');
}

// どこか上の方に追加
async function readJsonIfPossible(res) {
  const ct = (res.headers.get('content-type') || '').toLowerCase();
  if (!ct.includes('application/json')) return null; // HTML等は弾く
  try { return await res.json(); } catch { return null; }
}

// これで置き換え
// これで置き換え
async function fetchUserInfo() {
  // まず /api/me を最優先で
  const uid = getUserIdFromQuery() || localStorage.getItem('userId');
  const candidates = [
    '/api/me',
    '/user/me',
    ...(uid ? [`/user/${encodeURIComponent(uid)}`] : []),
    '/api/user/me'
  ];

  const normalize = (d) => ({
    id: d.id ?? d.userId ?? null,
    username: d.username ?? d.name ?? '',
    premium: Boolean(d.premium ?? d.isPremium),
    level: Number(d.level ?? 1),
    loginPoints: Number(d.loginPoints ?? 0),
    testCorrectTotal: Number(d.testCorrectTotal ?? 0)
  });

  for (const url of candidates) {
    try {
      const data = await fetchJSON(url);
      const u = normalize(data);
      user = u;
	  setPremium(!!u.premium);

      if (u.id) localStorage.setItem('userId', String(u.id));
      document.getElementById("username").innerText  = `${u.username} さん、ようこそ！`;
      document.getElementById("planText").innerText  = `プラン: ${u.premium ? "プレミアム" : "無料"}`;
      document.getElementById("userLevel").innerText = `レベル: Lv.${u.level}`;
      updateGirlVisual(u.level);

      // ログボの更新＆表示
      const ok = await updateLoginPointsIfNeeded(u.id);
      if (!ok) {
        const points = Number.isFinite(u.loginPoints) ? u.loginPoints : 1;
        setLoginDays(points);
        showLoginBonusOncePerDay(points);
      }
      return true;
    } catch (_) { /* 次の候補へ */ }
  }

  // ★ ここからフォールバック：APIが全部ダメでも userId がURLにあれば“ゲスト”で進める
  const fallbackId = getUserIdFromQuery();
  if (fallbackId) {
    user = {
      id: String(fallbackId),
      username: 'ゲスト',
      premium: false,
      level: 1,
      loginPoints: 0,
      testCorrectTotal: 0
    };
    localStorage.setItem('userId', String(fallbackId));
    document.getElementById("username").innerText  = `ゲストさん、ようこそ！`;
    document.getElementById("planText").innerText  = `プラン: 無料`;
    document.getElementById("userLevel").innerText = `レベル: Lv.1`;
    updateGirlVisual(1);
    // ログボは推計で表示（失敗しても無視）
    try { await updateLoginPointsIfNeeded(fallbackId); } catch {}
    return true; // ← ここで true を返すのがポイント（以降の描画に進む）
  }

  console.warn('user info could not be fetched as JSON');
  return false;
}
	
// 不存在の PUT をやめて、weekly から日数推計だけにする
async function updateLoginPointsIfNeeded(userId) {
  try {
    const res = await apiFetch(`/api/test/weekly?userId=${encodeURIComponent(userId)}`);
    const ct  = (res.headers.get('content-type')||'').toLowerCase();
    if (!res.ok || !ct.includes('application/json')) return false;
    const w = await res.json();
    const days = Array.isArray(w) ? w.filter(d => (d.answers ?? 0) > 0).length : 0;
    const p = Math.max(1, days);
    setLoginDays(p);
    showLoginBonusOncePerDay(p);
    return true;
  } catch { return false; }
}

// 1日1回だけポップアップ
function showLoginBonusOncePerDay(points){
  const d = new Date();
  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  const key = `loginBonusShown:${ymd}`;
  if (localStorage.getItem(key) === '1') return;
  showLoginBonus(points);
  localStorage.setItem(key, '1');
}

// 単語取得：まずセッション認可、空なら userId 付きで再試行
async function fetchWordsFromServer(part) {
  const tryUrls = [
    `/api/words?part=${encodeURIComponent(part)}`,
    `/words?part=${encodeURIComponent(part)}`
  ];
  const withUserId = (u) => `${u}&userId=${encodeURIComponent(getUserId())}`;

  for (const base of tryUrls) {
    // 1st: セッションのみ
    for (const url of [base]) {
      try {
        const res = await apiFetch(url, { headers:{Accept:'application/json'} });
        if (res.ok) {
          const data = await readJsonIfPossible(res);
          if (Array.isArray(data) && data.length) {
            return data.map(w => normalizeWord({ ...w, status: !!(w.status ?? w.learned) }));
          }
        }
      } catch {}
    }
    // 2nd: userId を付けて再試行
    try {
      const res = await apiFetch(withUserId(base), { headers:{Accept:'application/json'} });
      if (res.ok) {
        const data = await readJsonIfPossible(res);
        if (Array.isArray(data)) {
          return data.map(w => normalizeWord({ ...w, status: !!(w.status ?? w.learned) }));
        }
      }
    } catch {}
  }
  console.warn('words endpoint not ready');
  return [];
}


//=== 広告表示トリガ用のカウンタと保留実行 ===
let pendingToggle = null;

function getBeautyClickCount() {
  const n = parseInt(localStorage.getItem('beauty_clicks') || '0', 10);
  return isNaN(n) ? 0 : n;
}
function incBeautyClickCount() {
  const n = getBeautyClickCount() + 1;
  localStorage.setItem('beauty_clicks', String(n));
  return n;
}
function resetBeautyClickCount() {
  localStorage.setItem('beauty_clicks', '0');
}

// 既存の showAdModalForToggle / closeAdModal を差し替え
let removeTrapAd = null;

function showAdModalForToggle(callback) {
  pendingToggle = callback;
  const m = document.getElementById('adModal');
  if (!m) { console.error('adModal not found'); return; }
  m.style.display = 'flex';
  m.setAttribute('role','dialog');
  m.setAttribute('aria-modal','true');
  removeTrapAd = trapFocus(m);
  document.body.classList.add('modal-open');
  m.querySelector('#watchAdBtn')?.focus();
}

function closeAdModal() {
  const m = document.getElementById('adModal');
  m.style.display = 'none';
  removeTrapAd?.(); removeTrapAd = null;
  document.body.classList.remove('modal-open');
}

// 既存のモーダルのボタンIDに対応（下のモーダルHTMLそのまま使えます）
function handleAdAccept() {
 // ここで報酬型広告を表示
  showAd();          // ← 5分解放のwatchAdGlobalは使わない
  closeAdModal();    // モーダルは閉じてOK（成功時は onAdWatchedSuccess() が呼ばれる）
}


// スクリプト上部のどこか（他関数の外）に置く
function esc(s=''){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function safeSrc(u, { allowDataImage=false, allowData=false, allowBlob=false } = {}){
  try{
    const url = new URL(u, location.origin);
    const isHttp = url.protocol === 'http:' || url.protocol === 'https:';
    const isData = url.protocol === 'data:' && (allowData || allowDataImage);
    const isBlob = url.protocol === 'blob:' && allowBlob;
    return (isHttp || isData || isBlob) ? url.href : '/images/beauty.png';
  } catch {
    return '/images/beauty.png';
  }
}
	
function escHTML(v=''){ return String(v)
  .replace(/&/g,'&amp;').replace(/</g,'&lt;')
  .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;'); }

function h(parts, ...vals){
  return parts.reduce((s, p, i) => s + p + (i < vals.length ? escHTML(vals[i]) : ''), '');
}

function renderWords() {
  const container = document.getElementById("wordContainer");
  if (!container) return;
  container.innerHTML = "";

  const start = (currentPage - 1) * pageSize;
  const pageWords = words.slice(start, start + pageSize);

  pageWords.forEach((word, index) => {
    const div = document.createElement("div");
    div.className = "word-card";

    const premiumUser = window.isPremium();
    const actionButton = ""; // 無料は非表示

    const checkboxId = `status-${word.id ?? 'na'}`;
	const canToggle  = Number.isFinite(word.id);
    const checked = word.status ? "checked" : "";
    const labelText = word.status ? "学習済み" : "未学習";

    const imageId = `img-${index}`;
    const toggleButtonId = `toggle-${index}`;
	const slug = toSlugForImage(word.word);
	const baseImg = '/images/beauty.png';
	const specificImg = `/images/${slug}_girl.png`;
	
	// ← id が無いデータでも衝突しないキーにする
	const keyBase  = (word.id != null && String(word.id) !== '') ? `id:${word.id}` : `slug:${slug}`;
	const stateKey = `imgState:${keyBase}`;
	
	// ← 初期表示は必ず beauty.png （キーが '2' のときだけ特別画像）
  	const saved = localStorage.getItem(stateKey);
	const initState = (saved === '2') ? '2' : '1';
	const initSrc   = (initState === '2') ? specificImg : baseImg;

	
	div.innerHTML = `
	  <div class="wc-img">
	    <img
	      id="${imageId}"
	      src="${initSrc}"
	      alt="${esc(word.word)}"
	      loading="lazy"
	      width="88" height="132" decoding="async" draggable="false"
	      data-state="${initState}"
	      data-word-id="${word.id ?? ''}"
	      data-key="${stateKey}"
	    >
	  </div>

        <div class="wc-body">
        　<div class="wc-head">
          <strong>${esc(word.word)}</strong>
          ${window.isPremium() ? `
            <span class="remaining-inline is-premium">無制限</span>
          ` : `
            <span class="remaining-inline">${
             remainingCards > 0 ? `残り ${remainingCards} 枚` : '広告で +6 枚'
            }</span>
          `}
        </div>
        <div class="meta">（${esc(word.meaning)}）</div>
        <div class="meta">
          ステータス:
        <input type="checkbox" id="${checkboxId}" ${checked} ${canToggle ? '' : 'disabled'}
		  data-word-id="${word.id}"
		  data-part="${esc(selectedPart)}">
          <span id="status-label-${word.id ?? 'na'}">${labelText}</span>
        </div>
      </div>

<div class="wc-actions">
    <!-- 画像トグル用 -->
	<button
	  type="button"
	  class="js-toggle"
	  id="${toggleButtonId}"
	  data-img-id="${imageId}"
	  data-base="${esc(baseImg)}"
	  data-specific="${esc(specificImg)}"
	  data-index="${index}"
	  aria-controls="${imageId}"
	  aria-pressed="${initState === '2' ? 'true' : 'false'}"
	  aria-label="『${esc(word.word)}』の画像を切り替え"
	>美女で英単語を表現する</button>

    <!-- 動画再生（ある場合だけ） -->
    ${word.videoUrl ? `
      <button
        type="button"
        class="js-play"
        data-video="${esc(word.videoUrl)}"
      >動画を見る</button>` : ``}

    ${actionButton ? `<div style="margin-top:6px">${actionButton}</div>` : ""}
  </div>
	    `;
    container.appendChild(div);
  }); // ← ここが抜けてました！

  renderPagination(words.length);
　updateRemainingInline();
}

let _delegationReady = false;
function setupWordDelegation(){
  if (_delegationReady) return;
  _delegationReady = true;

  const root = document.getElementById("wordContainer");
　if (!root) return;

  root.addEventListener("click", (e) => {
    const tgl = e.target.closest("button.js-toggle");
    if (tgl) {
      const { imgId, base, specific, index } = tgl.dataset;
      handleToggleImage(imgId, tgl.id, base, specific, index);
      return;
    }
	const play = e.target.closest("button.js-play");
	if (play) {
	  const url = safeSrc(play.dataset.video, { allowData:true, allowBlob:true });
	  if (url) playVideo(url);
	}
  });

  root.addEventListener("change", (e) => {
    const cb = e.target.closest('input[type="checkbox"][data-word-id]');
    if (!cb) return;
    toggleStatus(cb.checked, Number(cb.dataset.wordId), cb.dataset.part);
  });
}

// DOMContentLoaded 後 or renderWords() の直後に一回だけ
document.addEventListener("DOMContentLoaded", setupWordDelegation);




function toggleImage(imgId, btnId, img1, img2, index) {
  const imgElem   = document.getElementById(imgId);
  const btn       = document.getElementById(btnId);

  // ← ここがポイント：renderWordsと同じキーを使う
  const stateKey  = imgElem?.dataset?.key ||
                    (imgElem?.dataset?.wordId ? `imgState:id:${imgElem.dataset.wordId}` : null);

  const nextState = (imgElem.dataset.state === '2') ? '1' : '2';
  const nextSrc   = (nextState === '2') ? img2 : img1;

  const test = new Image();
  test.onload = () => {
    imgElem.src = nextSrc;
    imgElem.dataset.state = nextState;
    if (btn) btn.setAttribute('aria-pressed', nextState === '2' ? 'true' : 'false');
    if (stateKey) localStorage.setItem(stateKey, nextState);
  };
  test.onerror = () => {
    imgElem.src = img1;
    imgElem.dataset.state = '1';
    if (btn) btn.setAttribute('aria-pressed', 'false');
    if (stateKey) localStorage.setItem(stateKey, '1');
  };
  test.src = nextSrc;
}

function handleToggleImage(imgId, btnId, img1, img2, index){
  const proceed = () => toggleImage(imgId, btnId, img1, img2, index);
  if (window.isPremium()){ proceed(); return; }
  if (!consumeOne()) return;  // 残0なら広告→終了
  proceed();
}

function renderPagination(totalItems) {
  const pageCount = Math.ceil(totalItems / pageSize);
  const bottom = document.getElementById("pagination");
  const containers = [bottom].filter(Boolean); // ← 上は使わない

  containers.forEach(c => c.innerHTML = "");
  if (pageCount <= 1) return;

  const build = (wrap) => {
    const makeBtn = (label, page, disabled = false, active = false) => {
      const btn = document.createElement("button");
      btn.textContent = label;
      if (disabled) btn.disabled = true;
      if (active) btn.classList.add("active");
      btn.addEventListener("click", () => {
        if (disabled || !page || page === currentPage) return;
        const oldTop = wrap.getBoundingClientRect().top;
        currentPage = page;
        renderWords();
        requestAnimationFrame(() => {
          const newTop = wrap.getBoundingClientRect().top;
          window.scrollBy(0, newTop - oldTop);
        });
      });
      return btn;
    };
    const addPage = (n) => wrap.appendChild(makeBtn(String(n), n, false, n === currentPage));
    const addDots = () => { const s=document.createElement("span"); s.className="ellipsis"; s.textContent="…"; wrap.appendChild(s); };

    wrap.appendChild(makeBtn("‹", currentPage - 1, currentPage === 1));
    if (pageCount <= 5) for (let i=1;i<=pageCount;i++) addPage(i);
    else if (currentPage <= 3){ addPage(1);addPage(2);addPage(3);addDots();addPage(pageCount); }
    else if (currentPage >= pageCount-2){ addPage(1);addDots();addPage(pageCount-2);addPage(pageCount-1);addPage(pageCount); }
    else { addPage(1);addDots();addPage(currentPage-1);addPage(currentPage);addPage(currentPage+1);addDots();addPage(pageCount); }
    wrap.appendChild(makeBtn("›", currentPage + 1, currentPage === pageCount));
  };

  containers.forEach(build);
}


// 置き換え
async function loadWords() {
  words = await fetchWordsFromServer(selectedPart);  // ← userIdを渡さない
  renderWords();

  updateStatusCount();

  document.getElementById("loginDays").textContent =
    `学習日数: ${user.loginPoints || 0}日目`;

  const correct = localStorage.getItem("test_correct") || 0;
  const total = localStorage.getItem("test_total") || 0;
  document.getElementById("testStats").textContent = `正答数: ${correct} / ${total}問中`;

  await refreshUserStats();
}

	
function isAdEnabled() {
	return window.isPremium() || remainingCards > 0;
}


function unlockCasualSuit() {
  alert("1000円で美女スーツ解放（仮）");
}

function playVideo(videoUrl) {
  const url = safeSrc(videoUrl, { allowData:true, allowBlob:true });
  if (!url) return;
  const modal = document.getElementById("videoModal");
  const player = document.getElementById("videoPlayer");
  player.src = url;
  modal.style.display = "flex";
  const stop = e => e.stopPropagation();
  player.addEventListener('click', stop);
  modal.onclick = () => {
    modal.style.display = "none";
    player.pause();
    player.currentTime = 0;
	player.src = ""; // ★追加
    player.removeEventListener('click', stop);
  };
}

	
// 置き換え
function updateGirlVisual(level) {
  const v = document.getElementById("girlVideo");
  const bg = document.getElementById("bgEffect");
  if (!v || !bg) return;

  // srcは原則いじらない。空ならだけ初期値を入れる
  if (!v.getAttribute('src')) {
    v.src = '/videos/girl_idle_loop.mp4';
  }
  // 404時はCDNにフォールバック
  v.onerror = () => {
    v.onerror = null;
    v.src =
      'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/videos/girl_idle_loop.mp4';
  };

  bg.className = level >= 20 ? "heart-bg" : "star-bg";
}



function toggleStatus(isChecked, wordId, part) {
　if (!Number.isFinite(wordId)) return; // id不明なら送らない
  apiFetch('/api/learning/update', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    // userId は送らない（サーバでセッション認可）
    body: JSON.stringify({ wordId, status: isChecked, part })
  })
  .then(response => {
    if (!response.ok) {
      alert("更新に失敗しました");
      return;
    }

    // 成功時のみフロント状態を反映
    const w = words.find(w => String(w.id) === String(wordId));  // ← 文字列比較に
    if (w) {
      w.status = isChecked;
      const statusSpan = document.getElementById(`status-label-${wordId}`);
      if (statusSpan) {
        statusSpan.innerText = isChecked ? "学習済み" : "未学習";
      }
    }

    updateStatusCount();
  })
  .catch(err => {
    console.error(err);
    alert("通信エラーが発生しました");
  });
}


function getSwipeExcludedSet(userId){
  const raw = localStorage.getItem(swipeTodayKey(userId));
  return new Set(raw ? JSON.parse(raw) : []); // ["123","456"]
}

function addToSwipeExcluded(userId, wordId){
  const key = swipeTodayKey(userId);
  const set = getSwipeExcludedSet(userId);
  set.add(String(wordId));
  localStorage.setItem(key, JSON.stringify([...set]));
}

// 学習済み件数
async function updateStatusCount() {
  const uid = getUserIdFromQuery() || getUserId();
  const urls = [
    `/api/learning/count?part=${encodeURIComponent(selectedPart)}&userId=${encodeURIComponent(uid)}`,
    `/learning/count?part=${encodeURIComponent(selectedPart)}&userId=${encodeURIComponent(uid)}`,
    `/api/learning/count?part=${encodeURIComponent(selectedPart)}`,
    `/learning/count?part=${encodeURIComponent(selectedPart)}`
  ];

  for (const url of urls) {
    try {
      const res = await apiFetch(url);
      if (!res.ok) continue;
	  const ct = (res.headers.get('content-type') || '').toLowerCase();
      const n  = Number(ct.includes('application/json') ? await res.json() : await res.text());
      const learned = Number.isFinite(n) ? n : 0;
      const total = words.length;
      document.getElementById("learningStatus").textContent =
        `学習済み: ${learned} / 未学習: ${Math.max(0, total - learned)}`;
      return;
    } catch {}
  }
  document.getElementById("learningStatus").textContent = "学習状況の取得に失敗しました";
}

async function loadWeeklyAnswers(){
  const uid = getUserIdFromQuery() || getUserId();
  if (!uid) return;

  const candidates = [
    `/api/test/weekly?userId=${encodeURIComponent(uid)}`,
    `/api/test/weekly` // フォールバック
  ];

  for (const url of candidates) {
    try {
      const res = await apiFetch(url);
      const ct = (res.headers.get('content-type') || '').toLowerCase();
      if (!res.ok || !ct.includes('application/json')) continue;

      let data = await res.json();
      if (!Array.isArray(data) || data.length === 0) {
        document.getElementById('weeklyBars').innerHTML = '';
        document.getElementById('weeklyLabels').innerHTML = '';
        return;
      }

      data = data.slice().sort((a,b)=> new Date(a.ymd) - new Date(b.ymd));

      const barsEl   = document.getElementById('weeklyBars');
      const labelsEl = document.getElementById('weeklyLabels');
      barsEl.innerHTML = ''; labelsEl.innerHTML = '';

      const maxAnswers = Math.max(1, ...data.map(d => Number(d.answers || 0)));
      const scaleH = 130;

      data.forEach(d => {
        const answers = Number(d.answers || 0);
        const correct = Number(d.correct || 0);
        const h = Math.max(answers === 0 ? 6 : Math.round((answers / maxAnswers) * scaleH), 6);

        const col = document.createElement('div');
        col.className = 'weekly-day';

        const num = document.createElement('div');
        num.className = 'weekly-num';
        num.textContent = String(correct);
        col.appendChild(num);

        const bar = document.createElement('div');
        bar.className = 'weekly-bar';
        bar.style.height = `${h}px`;
        bar.title = `正解: ${correct} / 解答: ${answers}`;
        col.appendChild(bar);
        barsEl.appendChild(col);

        const dt = new Date(d.ymd);
        const mm = String(dt.getMonth()+1).padStart(2,'0');
        const dd = String(dt.getDate()).padStart(2,'0');
        const youbi = ['日','月','火','水','木','金','土'][dt.getDay()];
        const lab = document.createElement('div');
        lab.className = 'weekly-label';
        lab.innerHTML = `<div>${mm}/${dd}</div><div style="opacity:.75">${youbi}</div>`;
        labelsEl.appendChild(lab);
      });
	　 // 念のためJS側でも表示を強制
　　　　barsEl.style.display = 'flex'; labelsEl.style.display = 'flex';
      return;
    } catch {}
  }
  console.warn('weekly endpoint returned non-JSON, skip');
}

// フォーカストラップ
function trapFocus(modal){
  const SEL = 'a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])';
  const getNodes = ()=> Array.from(modal.querySelectorAll(SEL)).filter(el=>!el.disabled && el.offsetParent!==null);
  function onKeydown(e){
    if (e.key !== 'Tab') return;
    const nodes = getNodes(); if (!nodes.length) return;
    const first = nodes[0], last = nodes[nodes.length-1];
    if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
  }
  modal.addEventListener('keydown', onKeydown);
  return ()=> modal.removeEventListener('keydown', onKeydown);
}

// 例：ログインボーナス
let removeTrapLoginBonus = null;
function showLoginBonus(points){
  const title = document.getElementById('loginBonusTitle');
  const grid  = document.getElementById('stampGrid');
  title.textContent = 'ログインボーナス（学習日数: ' + points + '日目）';
  grid.innerHTML = '';
  for (let i=1;i<=7;i++){
    const cell = document.createElement('div');
    cell.style.cssText = 'aspect-ratio:1/1;border:1px dashed #f48fb1;border-radius:8px;display:flex;align-items:center;justify-content:center;';
    cell.textContent = (i <= (points%7||7)) ? '✅' : '—';
    grid.appendChild(cell);
  }
  const popup = document.getElementById('loginBonusPopup');
  popup.style.display = 'flex';
  popup.style.flexDirection = 'column';
  popup.setAttribute('role','dialog');
  popup.setAttribute('aria-modal','true');
  popup.setAttribute('aria-labelledby','loginBonusTitle');
  removeTrapLoginBonus = trapFocus(popup);
  document.body.classList.add('modal-open');
}
	
function closeLoginBonus(){
  const popup = document.getElementById('loginBonusPopup');
  popup.style.display = 'none';
  removeTrapLoginBonus?.();
  document.body.classList.remove('modal-open');
}


	
function getTitleByLevel(level) {
		  if (level >= 20) return "ホットパンツの覇者";
		  if (level >= 15) return "セクシー学習王";
		  if (level >= 10) return "フリフリ美女マスター";
		  if (level >= 5) return "Newbie";
		  return "ビギナー";
}
	
function showPremiumPopup() {
  // すでにプレミアムなら案内だけ
  if (typeof window.isPremium === 'function' && window.isPremium()) {
    Swal.fire({ icon: 'success', title: 'もうプレミアムです🎀', timer: 1600, showConfirmButton: false });
    return;
  }

  Swal.fire({
    title: '🎀 美女単プレミアムプラン 🎀',
    html: `
      <div style="text-align:left; font-size: 0.95rem;">
        <p>全モード解放＆広告なしの贅沢体験</p>
        <ul style="line-height:1.6;">
          <li>✔ リスニングモード解放</li>
          <li>✔ テスト回数無制限＆成績履歴も保存</li>
        </ul>
        <p style="font-weight:bold; font-size:1.1rem;">💰 月額300円（税込）</p>
        <p style="color:red;">✨ 今だけ初月100円キャンペーン中 ✨</p>
        <small>SNSでシェアすると1週間無料体験🎁</small>
      </div>
    `,
    showCancelButton: true,
    confirmButtonText: "プレミアムに登録する",
    cancelButtonText: "あとで見る",
    allowOutsideClick: false,
    customClass: { popup: 'premium-popup', confirmButton: 'btn-premium' }
  }).then(async ({ isConfirmed }) => {
    if (!isConfirmed) return;

    // ---- iOSアプリ（WKWebView）なら StoreKit へ ----
    if (typeof isIOSApp === 'function' && isIOSApp()) {
	  console.log('[SK] iOS branch. Asking entitlements then purchase...');
      try {
        // 既存購入の権利があれば即時反映（onStoreKitMessage で受け取る）
        skPost('checkEntitlements');
        // 未購入なら購入シート表示（商品IDは App Store Connect と一致させる）
        skPost('purchase', { productId: (typeof SK_PRODUCT_ID !== 'undefined' ? SK_PRODUCT_ID : 'premium_unlock_300') });
      } catch (e) {
        console.warn('StoreKit purchase start failed:', e);
        Swal.fire({ icon: 'error', title: '購入を開始できませんでした', text: 'しばらくしてからお試しください。' });
      }
      return;
    }
	console.log('[Stripe] Web/PWA branch. Creating checkout session...');

    // ---- Web / PWA は Stripe チェックアウトへ遷移 ----
    try {
      const r = await apiFetch('/api/payment/create-checkout-session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({})
      });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);

      const ct = r.headers.get('content-type') || '';
      const data = ct.includes('application/json') ? await r.json() : null;
      const url = data?.checkoutUrl || data?.url;
      if (!/^https?:\/\//.test(url)) throw new Error('bad url');

      // Stripe ホストへ遷移（決済後は session_id 付きで戻る想定）
      location.assign(url);
    } catch (e) {
      console.error('checkout failed:', e);
      // 失敗時のフォールバック（説明ページなど）
      window.location.href = '/premium.html';
    }
  });
}

async function ensurePremiumTruth() {
  try {
    // ネイティブがあればそれを信頼
    if (window.NativePremium?.isPremium) {
      const { value } = await window.NativePremium.isPremium();
      setPremium(!!value);
      return !!value;
    }
    // サーバにも聞く（Cookieセッション）
    const me = await fetchJSON('/api/me');
    setPremium(!!me?.premium);
    return !!me?.premium;
  } catch {
    return window.isPremium();
  }
}

async function startTest() {
  await ensurePremiumTruth();
  const userId   = getUserId();
  const testCount = localStorage.getItem("test_started");

  // すでに一度開始済みのユーザーに2回目以降で広告を出す例
  if (testCount && !window.isPremium()) {
    await showRewardedAd(); // ← ここが本番で実広告再生になる
  }

  if (window.isPremium()) {
    Swal.fire({
      title: "テストモードを選んでね",
      html: `
        <button id="readingBtn" class="swal2-confirm swal2-styled" style="margin: 5px;">📘 リーディング</button>
        <button id="listeningBtn" class="swal2-confirm swal2-styled" style="background:#3949ab;margin: 5px;">🎧 リスニング</button>
      `,
      showConfirmButton: false,
      didOpen: () => {
        document.getElementById("readingBtn").addEventListener("click", () => {
          localStorage.setItem("test_started", "1");
          window.location.href = `test.html?userId=${userId}&mode=reading`;
        });
        document.getElementById("listeningBtn").addEventListener("click", () => {
          localStorage.setItem("test_started", "1");
          window.location.href = `test.html?userId=${userId}&mode=listening`;
        });
      }
    });
  } else {
    Swal.fire({
      title: "リスニングモードはプレミアム専用🎧",
      html: `
        <p>今は <strong>リーディングモード</strong>のみご利用いただけます。</p>
        <p>🎀 プレミアム登録で <strong>音声リスニングテスト</strong>も可能に！</p>
      `,
      showCancelButton: true,
      confirmButtonText: "リーディングで始める",
      cancelButtonText: "プレミアムを見る",
    }).then(result => {
      if (result.isConfirmed) {
        localStorage.setItem("test_started", "1");
        window.location.href = `test.html?userId=${userId}&mode=reading`;
      } else if (result.dismiss === Swal.DismissReason.cancel) {
        showPremiumPopup();
      }
    });
  }
}
	
async function startVocabularyTest() {
  await ensurePremiumTruth();
  const userId   = getUserId();
  const testCount = localStorage.getItem("test_started");

  if (testCount && !window.isPremium()) {
    await showRewardedAd(); // ← 差し替え
  }

  if (window.isPremium()) {
    Swal.fire({
      title: "テストモードを選んでね",
      html: `
        <button id="readingBtn" class="swal2-confirm swal2-styled" style="margin: 5px;">📘 リーディング</button>
        <button id="listeningBtn" class="swal2-confirm swal2-styled" style="background:#3949ab;margin: 5px;">🎧 リスニング</button>
      `,
      showConfirmButton: false,
      didOpen: () => {
        document.getElementById("readingBtn").addEventListener("click", () => {
          localStorage.setItem("test_started", "1");
          window.location.href = `vocabularyTest.html?userId=${userId}&mode=reading`;
        });
        document.getElementById("listeningBtn").addEventListener("click", () => {
          localStorage.setItem("test_started", "1");
          window.location.href = `vocabularyTest.html?userId=${userId}&mode=listening`;
        });
      }
    });
  } else {
    Swal.fire({
      title: "リスニングモードはプレミアム専用🎧",
      html: `
        <p>今は <strong>リーディングモード</strong>のみご利用いただけます。</p>
        <p>🎀 プレミアム登録で <strong>音声リスニングテスト</strong>も可能に！</p>
      `,
      showCancelButton: true,
      confirmButtonText: "リーディングで始める",
      cancelButtonText: "プレミアムを見る",
    }).then(result => {
      if (result.isConfirmed) {
        localStorage.setItem("test_started", "1");
        window.location.href = `vocabularyTest.html?userId=${userId}&mode=reading`;
      } else if (result.dismiss === Swal.DismissReason.cancel) {
        showPremiumPopup();
      }
    });
  }
}

function removeDebugNotes(){
  const phrases = [
    'html コードをコピーする',
    '日本語固定UI向け'
  ];
  document.querySelectorAll('body *').forEach(el => {
    const t = (el.textContent || '').trim();
    if (!t) return;
    if (phrases.some(p => t.includes(p))) {
      el.remove();
    }
  });
}
document.addEventListener('DOMContentLoaded', removeDebugNotes);
	
// 累計正答と学習日数を /user/me から更新。
// loginPoints がなければ /api/test/weekly から直近7日の学習日数相当を表示。
let _statsRetry = 0;
// 累計正答と学習日数を /user/me から更新。
// loginPoints がなければ /api/test/weekly から直近7日の学習日数相当を表示。
// 置き換え：/api/me 優先＋フォールバック
async function refreshUserStats() {
  const candidates = ['/api/me', '/user/me', '/api/user/me'];
  let u = null;

  for (const url of candidates) {
    try { u = await fetchJSON(url); break; } catch { /* 次の候補へ */ }
  }

  if (u) {
    // 学習日数
    const days = (typeof u.loginPoints === 'number') ? u.loginPoints : 0;
    const loginDaysEl = document.getElementById("loginDays");
    if (loginDaysEl) loginDaysEl.textContent = `学習日数: ${days}日目`;

    // 累計正答 → レベル更新
    const totalCorrect = Number(u.testCorrectTotal ?? 0);
    const testStatsEl = document.getElementById("testStats");
    if (testStatsEl) testStatsEl.textContent = `正答数（累計）: ${totalCorrect}`;

    const newLevel = Math.max(1, Math.floor(totalCorrect / 10) + 1);
    const currentLevel = Number(u.level ?? 1);
    if (currentLevel !== newLevel) {
      try {
        const r = await apiFetch(`/api/user/updateLevel`, {  // ← /api に統一
          method:'PUT',
          headers:{ 'Content-Type': 'application/json' },
          body: JSON.stringify({ userId: getUserId(), level: newLevel })
        });
        if (r.ok) {
          const j = await r.json().catch(()=>({}));
          u.level = Number(j.level ?? newLevel);
        } else {
          u.level = newLevel;
        }
      } catch {
        u.level = newLevel;
      }
    }
    const levelEl = document.getElementById("userLevel");
    const lv = Number(u.level ?? 1);
    if (levelEl) levelEl.textContent = `レベル: Lv.${lv}`;
    updateGirlVisual(lv);

    // レベル演出（前回との差分）
    const prev = parseInt(localStorage.getItem('previousCorrect') || '0', 10);
    const prevLv = Math.floor(prev / 10);
    const newLv  = Math.floor(totalCorrect / 10);
    if (newLv > prevLv) {
      for (let lv2 = prevLv + 1; lv2 <= newLv; lv2++) showLevelUpPopup(lv2);
    }
    localStorage.setItem('previousCorrect', String(totalCorrect));
    return;
  }

  // フォールバック：直近7日の学習日数相当
  try {
    const r2 = await apiFetch('/api/test/weekly');
    const ct = r2.headers.get('content-type') || '';
    if (r2.ok && ct.includes('application/json')) {
      const w = await r2.json();
      const days = Array.isArray(w) ? w.filter(d => (d.answers ?? 0) > 0).length : 0;
      const loginDaysEl = document.getElementById("loginDays");
      if (loginDaysEl) loginDaysEl.textContent = `学習日数(直近7日): ${days}日`;
    }
  } catch {}
}
	
async function setUserPremium(userId) {
  try {
    const res = await apiFetch(`/api/user/updatePremium`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId })
    });
    if (!res.ok) throw new Error("更新に失敗");
    console.log("✅ プレミアム状態をDBに反映しました");
  } catch (e) {
    console.warn('setUserPremium failed:', e);
  }
}

	
	// ===== スワイプ学習モード =====
	let swipeWords = [];      // 今のパートの単語配列（スワイプ用）
	let swipeIndex = 0;       // 先頭から何枚目か
	let swipeLearned = 0;     // このセッションで「覚えた」にした数
	let swipeUnlearned = 0;   // このセッションで「覚えてない」にした数
	let swipeDrag = null;     // {startX, startY, el}
	// 既存のスワイプ用変数の近くに追加
	let currentSwipeMode = "unlearned"; // 'unlearned' or 'review'
	const SWIPE_THRESHOLD = 80; // 何px以上で確定とみなす
	
	// 🔸 今日の日付キー
	function swipeTodayKey(userId){
	  const d = new Date();
	  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
	  return `swipeExcluded:${userId}:${ymd}`;   // 例: swipeExcluded:1:2025-08-24
	}
	
	function todayKey(type){
		  const d = new Date();
		  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
		  return `swipe:${type}:${getUserId()}:${ymd}`;
		}

		function getTodaySet(type){
		  const raw = localStorage.getItem(todayKey(type));
		  return new Set(raw ? JSON.parse(raw) : []);
		}

		function addTodaySet(type, wordId){
		  const set = getTodaySet(type);
		  set.add(wordId);
		  localStorage.setItem(todayKey(type), JSON.stringify([...set]));
		}
	
function setSwipeModeVisible(show){
  const box = document.getElementById('swipeModeBox');
  box.classList.toggle('hidden', !show);

  // 一覧系の表示/非表示
  ['wordContainer','pagination','test-section','weeklyAnswersBox'].forEach(id=>{
    document.getElementById(id)?.classList.toggle('hidden', show);
  });

  document.querySelectorAll('button:not([type])').forEach(b => b.type = 'button');

  const isMobile = window.matchMedia('(max-width:480px)').matches;
  if (show && isMobile){
    box.classList.add('fullscreen');
    document.body.classList.add('swipe-open');
    requestAnimationFrame(resizeSwipeDeck);
  }else{
    box.classList.remove('fullscreen');
    document.body.classList.remove('swipe-open');
  }

  ['partButtons','partPagination'].forEach(id=>{
    document.getElementById(id)?.classList.toggle('hidden', show);
  });
}

function resizeSwipeDeck(){
  const box = document.getElementById('swipeModeBox');
  const deck = document.getElementById('swipeDeck');
  if (!box || !deck) return;
  // グリッドで1frにしているので明示指定は不要だが、
  // iOSの一部で高さが足りなく見える時の保険として最低高さだけ与える
  const h = Math.max(320, box.clientHeight - 96); // だいたいHUD+ヒントぶん
  deck.style.minHeight = h + 'px';
}
window.addEventListener('resize', () => {
  if (!document.getElementById('swipeModeBox').classList.contains('hidden')) {
    resizeSwipeDeck();
  }
});



	// ✅ スワイプ学習開始時：最初に広告 → 終了後モード選択
	function startSwipeMode(partValue = window.selectedPart) {
  window.placeSwipeBoxAboveStartButton?.(); // 既存の演出を踏襲
  window.selectedPart = partValue;

  const lockedParts = ["part4", "part5", "part6", "partHealing", "musou"];
  const isLocked = lockedParts.includes(window.selectedPart);
  const premium = window.isPremium?.();

  const htmlMsg = premium
    ? "プレミアムのため広告は表示されません。<br>学習を始めます！"
    : "学習開始前と終了時に広告が表示されます（計2回）<br>美女と一緒に楽しく学習しましょう！";

  Swal.fire({
    title: "美女スワイプ学習🎀",
    html: htmlMsg,
    icon: "info",
    confirmButtonText: premium ? "学習を始める" : "広告を見る",
    confirmButtonColor: "#e91e63",
    allowOutsideClick: false
  }).then(() => {
    if (!premium) {
      // ✅ 広告成功後にモード選択へ
      pendingToggle = () => { window.showSwipeModeSelection?.(); };
      showAd();
    } else {
      window.showSwipeModeSelection?.();
    }
  });
}
	// ✅ モード選択ダイアログ（分離して使いやすく）
	function showSwipeModeSelection() {
	  Swal.fire({
	    title: "モードを選んでね",
	    html: `
	      <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
	        <button id="btnUnlearned" class="swal2-confirm swal2-styled">未学習を覚える</button>
	        <button id="btnReview" class="swal2-confirm swal2-styled" style="background:#3949ab">復習チェック</button>
	      </div>
	    `,
	    showConfirmButton: false,
	    didOpen: () => {
	      document.getElementById("btnUnlearned").onclick = () => {
	        currentSwipeMode = "unlearned";
	        Swal.close();
	        initSwipeMode("unlearned");
	      };
	      document.getElementById("btnReview").onclick = () => {
	        currentSwipeMode = "review";
	        Swal.close();
	        initSwipeMode("review");
	      };
	    }
	  });
	}

function scrollToSwipeTop(){
  const box = document.getElementById('swipeModeBox');
  if (!box) return;
  box.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

/* A) 横方向のタッチ移動は既定動作を止める（iOS対策） */
function preventIOSBackSwipe(){
  const deck = document.getElementById('swipeDeck');
  if (!deck || deck._iosGuardInstalled) return;
  let sx = 0, sy = 0;
  deck.addEventListener('touchstart', e => {
    const t = e.touches && e.touches[0];
    if (!t) return;
    sx = t.clientX; sy = t.clientY;
  }, {passive:true});
  deck.addEventListener('touchmove', e => {
    const t = e.touches && e.touches[0];
    if (!t) return;
    const dx = Math.abs(t.clientX - sx);
    const dy = Math.abs(t.clientY - sy);
    if (dx > dy && dx > 8) {
      // 横方向の操作っぽい時だけ既定動作をキャンセル
      e.preventDefault();
    }
  }, {passive:false});
  deck._iosGuardInstalled = true;
}

/* B) スワイプ中だけ“戻るジェスチャー”を捕まえて一覧に戻す */
// これを1箇所に集約
let _ignoreNextPop = false;
let _backGuardHandler = null;

function enableSwipeBackGuard() {
  if (_backGuardHandler) return;
  history.pushState({ swipe: 'on' }, '');
  _backGuardHandler = () => {
    // ← 追加の pushState はしない
    exitSwipeMode(true); // fromBack = true
  };
  window.addEventListener('popstate', _backGuardHandler);
}

function disableSwipeBackGuard() {
  if (!_backGuardHandler) return;
  window.removeEventListener('popstate', _backGuardHandler);
  _backGuardHandler = null;
}

function exitSwipeMode(fromBack = false) {
  setSwipeModeVisible(false);
  renderWords();
  updateStatusCount();
  disableSwipeBackGuard();
  if (!window.isPremium()) showAd();

  // ← 「一覧に戻る」ボタン等で閉じたときだけ、ガード分の1つを戻す
  if (!fromBack) history.back();
}
	
async function initSwipeMode(mode = "unlearned"){
  currentSwipeMode = mode;
  setSwipeModeVisible(true);
  showSwipeHowToIfNeeded(); // setSwipeModeVisible(true) の直後など
  requestAnimationFrame(scrollToSwipeTop);  // ← 追加

  const userId = getUserIdFromQuery() || getUserId();
	// 該当部分のみ置き換え
	if (!Array.isArray(words) || words.length === 0) {
	  words = await fetchWordsFromServer(selectedPart); // ← userIdを渡さない
	}
  swipeWords = await buildSwipeDeck(mode);
  if (swipeWords.length === 0) {
    Swal.fire({icon:'info', title:(mode==="review"?"今日は復習がありません":"今日は未学習がありません")});
    setSwipeModeVisible(false);
    return;
  }
  swipeIndex = 0; swipeLearned = 0; swipeUnlearned = 0;
  await renderSwipeDeck();
  updateSwipeHUD();
  document.getElementById('swipeExitBtn').onclick = () => exitSwipeMode(false);

  // iOSの横スワイプ干渉対策（下の 3) とセット）
  preventIOSBackSwipe();
  enableSwipeBackGuard();
}		
		// 🔸 スワイプ用デッキを組む（未学習のみ + 今日の除外を引く）
// ランダムサンプル用ユーティリティ（Fisher–Yates）
// ランダムに配列をシャッフル（in-place）
// in-place shuffle
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/**
 * 未学習を優先して N 枚でデッキ構築（未学習:reviewRatio[0], 復習:reviewRatio[1]）
 * 足りないときは相互に融通し、それでも足りなければ除外無視で補充
 */
//shuffle はそのまま利用

async function buildSwipeDeck(mode = "unlearned"){
  const userId   = getUserIdFromQuery() || getUserId();
  const excluded = getSwipeExcludedSet(userId);

  // 推奨
　const hasId = w => w && w.id != null && String(w.id).trim() !== '';
  const allUnlearned = words.filter(w => !w.status && hasId(w));
  const allLearned   = words.filter(w =>  w.status && hasId(w));

  let unlearned = allUnlearned.filter(w => !excluded.has(String(w.id)));
  let learned   = allLearned  .filter(w => !excluded.has(String(w.id)));

  // 復習候補ゼロの救済はそのまま
  if (mode === "review" && learned.length === 0 && allLearned.length > 0) {
    learned = allLearned.slice();
  }
  shuffle(unlearned); shuffle(learned);
  if (mode === "unlearned") return shuffle(unlearned.slice(0, 10));
  if (mode === "review")    return shuffle(learned.slice(0, 10));
  return shuffle([...unlearned.slice(0,25), ...learned.slice(0,5)]);
}
	
	// デッキ描画（先頭3枚だけ積む）
// デッキ描画（先頭3枚だけ積む）
async function renderSwipeDeck(){
  // DOMのデッキ要素
  const deckEl = document.getElementById('swipeDeck');
  deckEl.innerHTML = '';

  // swipeWords がまだ用意されていなければ作る
if (!Array.isArray(swipeWords) || swipeWords.length === 0) {
	// 現在選択中のモードでデッキを作る
	swipeWords = await buildSwipeDeck(currentSwipeMode);
	console.log('deck size:', swipeWords.length,
            'unlearned total:', words.filter(w=>!w.status).length,
            'learned total:', words.filter(w=> w.status).length);
}

  // 今の位置から3枚だけ描画
  const show = swipeWords.slice(swipeIndex, Math.min(swipeIndex + 3, swipeWords.length));

  show.forEach((w, idx) => {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.style.zIndex = String(100 - idx);
    card.dataset.index = String(swipeIndex + idx);

    // renderSwipeDeck
	const src = safeSrc(imageUrlForWord(w), { allowDataImage: true });

    card.innerHTML = `
    	  <div class="swipe-badge badge-left">覚えてない</div>
    	  <div class="swipe-badge badge-right">覚えた！</div>
    	  <div class="swipe-word">${esc(w.word)}</div>
    	  <div class="swipe-mean">(${esc(w.meaning)})</div>
    	  <img class="swipe-img" src="${src}" alt="${esc(w.word)}" draggable="false">
    	`;

    // 画像が404の時はデフォルトにフォールバック
    const imgEl = card.querySelector('.swipe-img');
    imgEl.onerror = () => { imgEl.src = '/images/beauty.png'; };

    attachSwipeHandlers(card);
    deckEl.appendChild(card);
  });
}


	// 1枚のカードにドラッグ/タッチ操作を付与
function attachSwipeHandlers(card){
  card.addEventListener('pointerdown', e => {
    e.preventDefault();                 // ← 既定動作(画像ドラッグ等)を抑止
    card.setPointerCapture(e.pointerId);
    swipeDrag = {startX:e.clientX, startY:e.clientY, el:card};
    card.style.transition = 'none';
  });

  card.addEventListener('pointermove', e => {
    if(!swipeDrag || swipeDrag.el!==card) return;
    const dx = e.clientX - swipeDrag.startX;
    const dy = e.clientY - swipeDrag.startY;
    const rot = dx * 0.05;
    card.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
    const left  = card.querySelector('.badge-left');
    const right = card.querySelector('.badge-right');
    if(dx < -20){ left.style.opacity = Math.min(1, (-dx)/80); right.style.opacity = 0; }
    else if(dx > 20){ right.style.opacity = Math.min(1, (dx)/80); left.style.opacity = 0; }
    else { left.style.opacity = right.style.opacity = 0; }
  });

  card.addEventListener('pointerup',     e => endSwipe(card, e));

  // ← ここを“リセットのみ”に
  card.addEventListener('pointercancel', () => {
    card.style.transition = '.2s ease';
    card.style.transform = 'translate(0,0) rotate(0)';
    card.querySelector('.badge-left').style.opacity  = 0;
    card.querySelector('.badge-right').style.opacity = 0;
    swipeDrag = null;
  });

  // 念のため HTML5 の dragstart も殺す
  card.addEventListener('dragstart', e => e.preventDefault());
}


	function endSwipe(card, e){
	  if(!swipeDrag){ return; }
	  const dx = e.clientX - swipeDrag.startX;
	  swipeDrag = null;

	  // 確定判定
	  if(dx <= -SWIPE_THRESHOLD){
	    // 左：覚えてない
	    decideSwipe(card, 'left');
	  }else if(dx >= SWIPE_THRESHOLD){
	    // 右：覚えた
	    decideSwipe(card, 'right');
	  }else{
	    // 戻す
	    card.style.transition = '.2s ease';
	    card.style.transform = 'translate(0,0) rotate(0)';
	    card.querySelector('.badge-left').style.opacity = 0;
	    card.querySelector('.badge-right').style.opacity = 0;
	  }
	}

	// 反映＆次のカードへ
// 既存の decideSwipe を丸ごと置き換え
async function decideSwipe(card, dir){
  const i = swipeIndex;
  const w = swipeWords[i];
  const isRight = (dir === 'right');

  // アニメ
  card.style.transition = '.2s ease';
  const off = (isRight ? 600 : -600);
  card.style.transform = `translate(${off}px,-40px) rotate(${off>0?15:-15}deg)`;
  setTimeout(() => card.remove(), 200);

  if (currentSwipeMode === "unlearned") {
    if (isRight) {
      addTodaySet('learned', w.id);
      addToSwipeExcluded(getUserId(), w.id);
      swipeLearned++;
      onSwipeRightLearned(w);
      swipeIndex++; // 右は確定なので進める
    } else {
      // ← 左は今の要素を末尾へ移動（重複させない）
      const [cur] = swipeWords.splice(i, 1);
      swipeWords.push(cur);
      addTodaySet('unlearned', w.id);
      swipeUnlearned++;
      // swipeIndex は据え置き：同じ i に次のカードが入る
    }
  } else { // review
    if (isRight) { swipeLearned++; addTodaySet('review_ok', w.id); }
    else         { swipeUnlearned++; addTodaySet('review_ng', w.id); }
    addToSwipeExcluded(getUserId(), w.id);
    swipeIndex++;
  }

  updateSwipeHUD();

  if (!window.isPremium() && AD_EVERY_SWIPE > 0 &&
      swipeIndex % AD_EVERY_SWIPE === 0 &&
      swipeIndex < swipeWords.length) {
    showAd();
  }

  if (swipeIndex < swipeWords.length) await renderSwipeDeck();
  else                                 exitSwipeMode();
}



//既存の updateSwipeHUD を丸ごと置き換え
function updateSwipeHUD(){
  const total = swipeWords.length;
  document.getElementById('swipeCounter').textContent = `${swipeIndex}/${total}`;

  if (currentSwipeMode === "unlearned") {
    // 当日メモ（未学習用）
    const learnedSet   = getTodaySet('learned');
    const unlearnedSet = getTodaySet('unlearned');
    document.getElementById('swipeStats').textContent =
      `覚えた: ${learnedSet.size} / 覚えてない: ${unlearnedSet.size}`;
  } else {
    // セッションカウント（復習用）
    document.getElementById('swipeStats').textContent =
      `OK: ${swipeLearned} / 忘れていた: ${swipeUnlearned}`;
  }
}

// 先頭あたりに
const getCSRFFromCookie = (name='_csrf') => {
  const m = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]+)`));
  return m ? decodeURIComponent(m[1]) : null;
};

// 置き換え
// ← これで置き換え
async function onSwipeRightLearned(word){
    if (!Number.isFinite(word?.id)) {
    // id無しはDB更新スキップ。今日の除外だけ反映
    addToSwipeExcluded(getUserId(), word.id);
    return;
  }
  try{
    await apiFetch('/api/learning/update', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ wordId: word.id, status: true, part: selectedPart })
    });
    const w = words.find(x => String(x.id) === String(word.id));
    if (w) w.status = true;
    addToSwipeExcluded(getUserId(), word.id);
  }catch(e){
    console.warn('update failed (swipe right):', e);
  }
}  
    const SWIPE_TUTOR_KEY = 'swipe_tutorial_shown_v1';

    function showSwipeHowToIfNeeded(){
      if (localStorage.getItem(SWIPE_TUTOR_KEY) === '1') return;
      Swal.fire({
        title: 'スワイプ学習のコツ',
        html: `
          <div style="text-align:left;line-height:1.8">
            <p>・右スワイプ = <b>覚えた！→ 学習済みに反映</b></p>
            <p>・左スワイプ = まだ覚えてない（デッキ後方へ）</p>
            <p>・今日覚えた単語は、<b>その日は再表示されません</b></p>
            <p>・対象は <b>未学習だけ</b>。効率よく覚えよう！</p>
          </div>
        `,
        confirmButtonText: 'OK',
        confirmButtonColor: '#e91e63'
      }).then(()=> localStorage.setItem(SWIPE_TUTOR_KEY,'1'));
    }

document.addEventListener('keydown', (e) => {
  // Esc でモーダル類を閉じる
  if (e.key === 'Escape') {
    const ad = document.getElementById('adModal');
    if (ad?.style.display === 'flex') closeAdModal();

    const vm = document.getElementById('videoModal');
    const vp = document.getElementById('videoPlayer');
    if (vm?.style.display === 'flex') { vm.style.display = 'none'; vp?.pause(); }

    const box = document.getElementById('swipeModeBox');
    if (!box.classList.contains('hidden')) exitSwipeMode();
    return;
  }

  // スワイプ中のみ ← / → を効かせる
  const box = document.getElementById('swipeModeBox');
  if (box.classList.contains('hidden')) return;

  const top = document.querySelector(`.swipe-card[data-index="${swipeIndex}"]`);
  if (!top) return;

  if (e.key === 'ArrowRight') { e.preventDefault(); decideSwipe(top, 'right'); }
  if (e.key === 'ArrowLeft')  { e.preventDefault(); decideSwipe(top, 'left');  }
});
	</script>
　　<!-- カスタム広告・プレミアムモーダル -->
<div
  id="adModal"
  role="dialog"
  aria-modal="true"
  aria-labelledby="adModalTitle"
  style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:10000;"
>
  <div
  id="adModal"
  role="dialog"
  aria-modal="true"
  aria-labelledby="adModalTitle"
  style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:10000; align-items:center; justify-content:center;"
>
  <div role="document" style="margin:auto; background:#fff; border-radius:12px; padding:16px; width:min(420px,90%); box-shadow:0 8px 20px rgba(0,0,0,.2)">
    <h3 id="adModalTitle" style="margin:0 0 8px">広告を見る</h3>
    <p style="margin:8px 0 0">視聴すると<strong>5分間</strong>プレミアム機能が解放されます。</p>
    <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:16px">
      <button id="cancelAdBtn" class="btn btn-secondary" type="button">キャンセル</button>
      <!-- ✅ 準備できるまで disabled にする -->
      <button id="watchAdBtn" class="btn btn-primary" type="button" disabled>視聴する</button>
    </div>
  </div>
</div>

<script>
/* =========================================================
   AdMob bridge for Capacitor (Banner + Rewarded)
   - ネイティブ（Capacitor）: AdMob SDK を使用
   - ブラウザ/非ネイティブ  : confirm でフォールバック
   - ATT はネイティブ側（AppDelegate）で実施
   ========================================================= */

(() => {
  // ---- 環境判定 ----
  const isNative = !!(window.Capacitor && window.Capacitor.isNativePlatform && window.Capacitor.isNativePlatform());
  const isIOS     = /iPhone|iPad|iPod/i.test(navigator.userAgent);
  const isAndroid = /Android/i.test(navigator.userAgent);

  // ---- ユニットID ----
  const TEST = {
    banner:   isIOS ? 'ca-app-pub-3940256099942544/2934735716' : 'ca-app-pub-3940256099942544/6300978111',
    inter:    isIOS ? 'ca-app-pub-3940256099942544/4411468910' : 'ca-app-pub-3940256099942544/1033173712',
    rewarded: isIOS ? 'ca-app-pub-3940256099942544/1712485313' : 'ca-app-pub-3940256099942544/5224354917'
  };
  const PROD = {
    banner:   'ca-app-pub-3517487281025314/5267705016',
    inter:    'ca-app-pub-3517487281025314/6481656285',
    rewarded: 'ca-app-pub-3517487281025314/1240830098'
  };
  const useProd = false; // ← 本番に切り替えるなら true
  const AD_UNIT = useProd ? PROD : TEST;

  // ---- 状態管理（共通）----
  let adReady = false;           // GMA/AdMob 初期化が完了すると true
  let pendingToggle = null;      // 視聴成功後に実行するコールバック
  const AD_UNLOCK_MS = 5 * 60 * 1000; // 5分

  function enableAdFor5Min() {
    localStorage.setItem('adEnabledUntil', String(Date.now() + AD_UNLOCK_MS));
  }
  window.isAdEnabled = function isAdEnabled() {
    const until = Number(localStorage.getItem('adEnabledUntil') || 0);
    return until > Date.now();
  };

  // ---- モーダル制御（カスタムUI想定）----
  function openAdModal() {
    const modal = document.getElementById('adModal');
    if (modal) modal.style.display = 'flex';
    const btn = document.getElementById('watchAdBtn');
    if (btn) btn.disabled = !adReady; // 準備できるまで押せない
  }
  function closeAdModal() {
    const modal = document.getElementById('adModal');
    if (modal) modal.style.display = 'none';
  }

  // ---- AdMob 初期化 ----
  async function initAdMob() {
    const AdMob = window.AdMob;
    if (!isNative || !AdMob) return false; // 非ネイティブやプラグイン未ロードならフォールバックへ
    try {
      await AdMob.initialize({
        requestTrackingAuthorization: true,   // （ATT自体はネイティブで表示、ここは保険）
        initializeForTesting: !useProd
      });
      adReady = true;
      // 既にUIがあれば有効化
      const btn = document.getElementById('watchAdBtn');
      if (btn) btn.disabled = false;
      return true;
    } catch (e) {
      console.warn('[AdMob] init failed', e);
      return false;
    }
  }

  // ---- バナー表示（下固定）----
  async function showBottomBanner() {
    const AdMob = window.AdMob;
    if (!isNative || !AdMob) return;
    try {
      await AdMob.showBanner({
        adId: AD_UNIT.banner,
        adSize: 'BANNER',        // 必要に応じて 'ADAPTIVE_BANNER'
        position: 'BOTTOM_CENTER',
        isTesting: !useProd
      });
    } catch (e) {
      console.warn('[AdMob] banner error', e);
    }
  }

  // ---- バナー非表示 ----
  window.hideNativeBannerIfPossible = async function hideNativeBannerIfPossible() {
    const AdMob = window.AdMob;
    if (!isNative || !AdMob) return;
    try {
      await AdMob.hideBanner?.();
      await AdMob.removeBanner?.();
    } catch (e) {
      // no-op
    }
  };

  // ---- リワード実体 ----
  async function showRewardedAdReal() {
    const AdMob = window.AdMob;
    if (!isNative || !AdMob) throw new Error('NO_ADMOB');
    await AdMob.prepareRewardVideoAd({
      adId: AD_UNIT.rewarded,
      isTesting: !useProd
    });
    const res = await AdMob.showRewardVideoAd();
    // ここまで来たら視聴成功扱い（SDKによっては complete コールバックを使う）
    if (typeof window.onAdWatchedSuccess === 'function') window.onAdWatchedSuccess();
    return res;
  }

  // ---- 既定フック（未定義なら用意）----
  if (typeof window.onAdWatchedSuccess !== 'function') {
    window.onAdWatchedSuccess = function () {
      enableAdFor5Min();
      if (typeof pendingToggle === 'function') {
        const next = pendingToggle;
        pendingToggle = null;
        next();
      }
    };
  }
  if (typeof window.onAdClosedOrFailed !== 'function') {
    window.onAdClosedOrFailed = function () {
      // 任意：失敗時のUI
    };
  }

  // ---- showAd（公開API）----
  window.showAd = async function showAd() {
    // モーダルを開いて「視聴する」ボタンの活性/非活性を状態に同期
    openAdModal();

    // 1) 初期化（未完了ならここで実行）。失敗ならフォールバック
    if (!adReady) {
      const ok = await initAdMob();
      if (!ok) {
        // デモフォールバック
        const yes = window.confirm('【デモ】広告を最後まで視聴しましたか？\nOK=成功 / Cancel=キャンセル');
        closeAdModal();
        yes ? window.onAdWatchedSuccess?.() : window.onAdClosedOrFailed?.();
        return;
      }
    }

    // 2) 無料ユーザーなら下部バナーも（失敗は無視）
    try {
      if (!(typeof window.isPremium === 'function' && window.isPremium())) {
        await showBottomBanner();
      }
    } catch (_) {}

    // 3) 「視聴する」ボタンのクリックで実際にリワード再生
    const btn = document.getElementById('watchAdBtn');
    if (!btn) {
      // モーダルを使わない設計の場合はすぐ再生
      try {
        await showRewardedAdReal();
      } catch (e) {
        console.warn('[AdMob] rewarded failed', e);
        window.onAdClosedOrFailed?.(e);
      } finally {
        closeAdModal();
      }
      return;
    }

    // 余計な多重bindを避けるため一旦既存ハンドラをクローン置換
    const btnClone = btn.cloneNode(true);
    btn.parentNode.replaceChild(btnClone, btn);
    btnClone.disabled = !adReady;

    btnClone.addEventListener('click', async () => {
      if (!adReady) return;
      btnClone.disabled = true; // 二重押し防止
      try {
        await showRewardedAdReal();
      } catch (e) {
        console.warn('[AdMob] rewarded failed', e);
        window.onAdClosedOrFailed?.(e);
      } finally {
        closeAdModal();
        btnClone.disabled = !adReady;
      }
    }, { once: true });
  };

  // ---- ネイティブ合図（AppDelegate → JS）----
  // 1) triggerJSEvent("gmaInitialized", target: "window")
  window.addEventListener('gmaInitialized', () => {
    adReady = true;
    const btn = document.getElementById('watchAdBtn');
    if (btn) btn.disabled = false;
  });
  // 2) 直接 onGmaInitialized() を呼ぶ場合
  window.onGmaInitialized = function () {
    adReady = true;
    const btn = document.getElementById('watchAdBtn');
    if (btn) btn.disabled = false;
  };

  // ---- 初期描画時：無料ユーザーなら下部バナー（可能時のみ）----
  document.addEventListener('DOMContentLoaded', async () => {
    try {
      if (typeof window.isPremium === 'function' && window.isPremium()) {
        await window.hideNativeBannerIfPossible();
        window.adjustBottomPadding?.();
        return;
      }
      const ok = await initAdMob();
      if (ok) await showBottomBanner();
    } catch (_) {}
  });

  // ---- プレミアム昇格時の後処理（呼び出し例）----
  window.markPremiumEnabled = async function markPremiumEnabled() {
    // ...既存の昇格処理...
    await window.hideNativeBannerIfPossible();
    window.adjustBottomPadding?.();
  };

  // ---- 公開: 視聴後に実行したい処理を登録するための setter ----
  window.setAdPendingToggle = function setAdPendingToggle(fn) {
    pendingToggle = typeof fn === 'function' ? fn : null;
  };
})();
</script>
	
</body>
</html>
