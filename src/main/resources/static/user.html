<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>美女単語（ユーザー）</title>
 <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">


  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 10px;
      background: rgb(249, 249, 249);
    }

    h1, h3 {
      text-align: center;
      color: rgb(233, 30, 99);
    }

    #username, #plan {
      display: block;
      text-align: center;
      margin: 10px 0;
      font-size: 1.1em;
    }
    
/* 画面を狭める：主要ブロックは最大幅を統一して中央に */
#user-info, #levelGirlContainer, #partButtons, #statsBox, #test-section, #weeklyAnswersBox, #wordContainer, #pagination, #partPagination  {
  max-width: 420px;
  margin-left: auto;
  margin-right: auto;
}

/* 単語カード：デフォも少しコンパクトに */
.word-card{
  padding: 10px 12px;
  margin: 10px auto;
}

/* 画像を小さめ固定比率に */
.word-card img{
  width: 88px;
  height: 132px;          /* 3:2～3:5程度に収める */
  object-fit: cover;
  border-radius: 8px;
}

/* ===== モバイル最適化 ===== */
@media (max-width: 480px){

   body.swipe-open{ overflow:hidden; }               /* 背景スクロール停止 */

  #swipeModeBox.fullscreen{
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100vh;            /* 旧端末フォールバック */
    height: 100svh;           /* iOS 15+ */
    height: 100dvh;           /* 新しい動的vh */
    background:#fff;
    z-index: 10000;
    margin: 0;
    padding:
      max(8px, env(safe-area-inset-top))
      8px
      max(10px, env(safe-area-inset-bottom));
    display: grid;
    grid-template-rows: auto 1fr auto;  /* 上:HUD / 中:デッキ / 下:ヒント */
    gap: 6px;
  }

  /* 中央のデッキは残り領域をフルで使う */
  #swipeDeck{ height: auto; display: grid; align-items: center; }

  /* カードを画面いっぱいに拡大（はみ出さないよう clamp） */
  .swipe-card{
    width: min(92vw, 560px);
    height: clamp(320px, 74dvh, 720px);
  }

  /* HUD/ヒントを固定っぽく見せる（スクロールでずれない） */
  .swipe-hud{ position: sticky; top: 0; background:#fff; padding-bottom: 4px; }
  .swipe-hints{ position: sticky; bottom: 0; background:#fff; padding-top: 4px; }

  /* 以前の「全ボタン幅90%」をやめる：縦の伸び防止 */
  button{ font-size: 0.95rem; padding: 10px; }

  /* 必要な場所だけ幅広ボタンにする */
  #wordContainer .word-card button,
  #test-section button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: 100%;
    max-width: 320px;
  }

  #partButtons button{ flex: 0 0 auto; }

  /* ページネーションも横並びスクロールで省スペース */
  .pagination{
    display:flex;
    gap:8px;
    overflow-x:auto;
    -webkit-overflow-scrolling:touch;
    flex-wrap:nowrap;
    justify-content:center;
    padding:6px 2px;
  }
  .pagination button{
    flex:0 0 auto;
    min-width:44px;
    height:36px;
  }
  #partPagination, .pagination{
    display:flex;
    justify-content:center;
    width:100%;
    max-width:420px;
    margin:0 auto;
  }

  /* 単語カード：2カラム化で縦長を解消 */
  .word-card{
    display: grid;
    grid-template-columns: 88px 1fr;
    grid-template-areas:
      "img text"
      "img action";
    align-items: center;
    gap: 8px 10px;
    font-size: 0.95rem;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; }
  .wc-actions{ grid-area: action; }

  .word-card strong{ display:block; margin-bottom: 4px; font-size: 1rem; }
  .word-card .meta{ color:#666; font-size: .85rem; margin-bottom: 4px; }

  /* ヒーローの女の子動画の高さを抑える */
  #levelGirlContainer video{ width: 160px; }
  #statsBox{ padding: 12px; }
  #weeklyAnswersBox{ padding: 0 4px; }
}


    .locked {
      background: #ffdddd;
      padding: 10px;
      text-align: center;
    }
    
    .musou-card {
	  background: #fff5f5;
	  border: 1px solid #f48fb1;
	  border-radius: 10px;
	  padding: 10px;
	  margin: 10px 0;
	}
    

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 20px;
      background-color:#e91e63;
      color: white;
      font-size: 1rem;
      margin: 5px;
      cursor: pointer;
    }

    button:hover {
      background-color: #f50057;
    }
    
#user-info {
  text-align: left; /* ← 中央から左寄せに変更 */
  margin: 10px 0 20px;
  font-size: 1.1rem;
  padding-left: 10px;
}

#bgEffect {
  position: absolute;
  width: 180px;
  height: 180px;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  z-index: -1;
}

.star-bg {
  background: radial-gradient(circle, #fff 20%, transparent 70%);
  animation: sparkle 1.5s infinite alternate;
}

.heart-bg{ background: radial-gradient(circle,#ffd1e6 30%, transparent 70%); }

@keyframes sparkle {
  0% { opacity: 0.6; transform: scale(1); }
  100% { opacity: 1; transform: scale(1.05); }
}


#planText {
  text-align: left; /* ← 中央から左寄せに変更 */
  color: #333;
  font-weight: bold;
}

    #partButtons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }
    
    #statsBox {
  background: #fff3f8;
  border: 1px solid #ff99c9;
  border-radius: 12px;
  padding: 15px;
  margin: 15px auto;
  max-width: 500px;
  box-shadow: 2px 2px 6px rgba(0,0,0,0.05);
  font-weight: bold;
  font-size: 1rem;
}

#learningStatus {
  text-align: center;
  margin-bottom: 10px;
  color: #333;
}

#subStats {
  display: flex;
  justify-content: space-between;
  font-size: 0.95rem;
  padding: 0 10px;
  color: #555;
}

#subStats div {
  flex: 1;
  text-align: center;
}
    
    
    

    #loginBonusPopup {
      display: none;
      position: fixed;
      top: 10%;
      left: 5%;
      width: 90%;
      height: 75%;
      background: white;
      border: 2px solid #ccc;
      z-index: 9999;
      padding: 20px;
      overflow: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }
    
    .swal2-popup.premium-popup {
  font-family: 'sans-serif';
  border-radius: 15px;
  padding: 20px;
  max-width: 400px;
}

    #stampGrid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
      gap: 10px;
    }

    #test-section {
      text-align: center;
      margin: 20px 0;
    }

    #videoModal {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.8);
      justify-content: center;
      align-items: center;
      z-index: 999;
    }

    video {
      width: 90%;
      max-height: 80vh;
    }

  /* 必要な場所だけ個別に幅を広げたい場合は明示的に指定 */
  #test-section button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: 90%;
    max-width: 320px;
  }

  /* Partボタンを横一列でスワイプ可能に */
  #partButtons {
    display: flex;
    gap: 8px;
    overflow-x: auto;           /* ← 横スクロール */
    -webkit-overflow-scrolling: touch;
    flex-wrap: nowrap;          /* 折り返さない */
    justify-content: flex-start;
    padding-top: max(6px, env(safe-area-inset-top));
  }
  #partButtons button {
    flex: 0 0 auto;             /* 収縮させない */
  }

.word-card {
        font-size: 0.9rem;
}
.btn { padding:10px 16px; border-radius:8px; border:none; cursor:pointer; }
.btn-primary { background:#e91e63; color:#fff; }
.btn-secondary { background:#999; color:#fff; }
    
.btn-premium {
    background-color: #e91e63;
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: 6px;
    font-size: 1em;
    margin-top: 10px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.btn-premium:hover {
    background-color: #d81b60;
}
  
  /* 既存CSSの末尾に追加 */
.hidden{display:none;}

#swipeModeBox{
  max-width:700px;margin:16px auto;padding:10px;
}
#swipeDeck{
  position:relative;height:360px;user-select:none;touch-action:pan-y;
}
.swipe-card{
  position:absolute;inset:0;margin:auto;width:92%;max-width:580px;height:340px;
  background:#fff;border-radius:14px;border:1px solid #eee;
  box-shadow:0 10px 24px rgba(0,0,0,.08);
  padding:18px;display:flex;flex-direction:column;justify-content:center;align-items:center;
  transition:transform .2s ease, opacity .2s ease;
}
.swipe-word{font-size:28px;font-weight:700;margin-bottom:8px;}
.swipe-mean{color:#555;margin-bottom:12px;}
.swipe-img{
  width:220px;height:300px;object-fit:cover;border-radius:10px;background:#f2f2f2;
  -webkit-user-drag: none;      /* Safari/Chrome */
  user-drag: none;
  user-select: none;
  pointer-events: none;          /* ← ドラッグの起点を常にカードにする */
}

.swipe-badge{
  position:absolute;top:12px;font-weight:700;padding:6px 10px;border-radius:8px;opacity:0;
}
.badge-left{left:12px;background:#fde68a;color:#92400e;}     /* 覚えてない */
.badge-right{right:12px;background:#dcfce7;color:#166534;}    /* 覚えた */

.swipe-hud{display:flex;justify-content:space-between;align-items:center;margin:6px 6px 10px;}
.swipe-hints{display:flex;justify-content:space-between;color:#888;margin-top:6px;padding:0 4px;}
@media (prefers-reduced-motion: reduce){
  .swipe-card{ transition: none; }
  .star-bg{ animation: none; }
  .caption{ display: none !important; }
}

/* ===== Desktop layout improvements ===== */
@media (min-width: 768px){
  /* メインブロックの幅を広げる */
#user-info, #levelGirlContainer, #partButtons, #statsBox,
#test-section, #weeklyAnswersBox, #wordContainer, #pagination, #partPagination{
   max-width: 900px;
   margin-left: auto;
   margin-right: auto;
 }

  /* 単語カードを3カラムで横並びに（画像 / テキスト / アクション） */
  .word-card{
    display: grid;
    grid-template-columns: 140px 1fr auto;
    grid-template-areas: "img text action";
    align-items: center;
    gap: 12px 16px;
    padding: 14px 16px;
  }
  .wc-img{ grid-area: img; }
  .wc-body{ grid-area: text; }
  .wc-actions{ grid-area: action; justify-self: end; }

  .word-card img{ width: 140px; height: 210px; }

  /* ボタンの無駄な横幅を解除（PCでは自動幅） */
  #test-section button,
  #swipeStartBtn,
  #swipeModeBox .swipe-hud button {
    width: auto;
    max-width: none;
  }

  /* パートボタンやページネーションは中央寄せ・折り返し */
  #partButtons{ justify-content: center; overflow: visible; flex-wrap: wrap; }
  .pagination{ justify-content: center; overflow: visible; }
}

/* ヒーロー背景のピンク丸はモバイルだけ表示、PCでは非表示 */
#levelGirlContainer{ position: relative; }
@media (min-width: 600px){ #bgEffect{ display:none; } }

/* pagination condensed */
.pagination .ellipsis{
  padding: 0 6px;
  color:#888;
  align-self:center;
}
.pagination button.active{
  background-color:#d81b60;
  font-weight:700;
}
.pagination button[disabled]{
  opacity:.5;
  cursor: default;
}

/* --- Login Bonus modal --- */
/* これに統一：JSで display を切り替える（flexはJSで当てる） */
#loginBonusPopup{
  display:none;           /* ← ここは none のまま */
  position:fixed;
  inset:4vh 3vw;
  background:#fff;
  border:2px solid #ccc;
  border-radius:12px;
  z-index:9999;
  box-shadow:0 8px 20px rgba(0,0,0,.15);
  padding:12px 12px 0;
  overflow:hidden;
  /* display:flex;  ← 削除！*/
  /* flex-direction:column; ← 削除！*/
}
#stampScroll{
  flex:1;                 /* ここがスクロール領域 */
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  padding:8px 2px 12px;
}
#stampGrid{
  display:grid;
  grid-template-columns: repeat(6, minmax(50px,1fr));
  gap:10px;
}
#loginBonusOkBtn{
  position:sticky; bottom:0;
  margin:8px auto calc(env(safe-area-inset-bottom) + 8px);
  width:min(380px, 90%);
}

/* 末尾に追記：位置を詰める */
#swipeModeBox{
  margin: 8px auto 0 !important;   /* 上の余白を小さく */
}
#swipeDeck{
  height: 340px !important;        /* わずかに浅くして画面上寄せ */
}
.swipe-hud{ margin: 4px 6px 8px !important; }

/* モバイルでは列数を減らしOKを押しやすく */
@media (max-width:480px){
  #stampGrid{ grid-template-columns: repeat(4, minmax(56px,1fr)); }
}

/* モーダル時は背景スクロールを止める */
body.modal-open{ overflow:hidden; height:100vh; }

/* CSSの一番最後に追加（スマホ全画面時の“勝ち”ルール） */
@media (max-width:480px){
  #swipeModeBox.fullscreen .swipe-card{
    height: clamp(320px, 74dvh, 720px) !important;
    width: min(92vw, 560px);
  }
  #swipeModeBox.fullscreen #swipeDeck{
    height: auto !important;
    min-height: 74dvh; /* 念のため */
  }
	
  #swipeModeBox:not(.fullscreen) #swipeDeck{
    height: 340px;            /* ← 通常表示のときだけ適用 */
  }
}
  
  </style>
	<script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>

<!-- スタンプカードポップアップ -->
<div id="loginBonusPopup">
  <h3 id="loginBonusTitle">ログインボーナス</h3>
  <div id="stampScroll"><div id="stampGrid"></div></div>
  <button id="loginBonusOkBtn" onclick="closeLoginBonus()">OK</button>
</div>


<div id="user-info">
  <div id="username"></div>
  <div id="planText"></div>
  <div id="userLevel"></div> <!-- ← 追加 -->
</div>
<div id="levelGirlContainer" style="text-align:center; margin: 10px 0;">
  <div id="bgEffect" class="star-bg"></div>
  <video id="girlVideo" preload="metadata" autoplay muted loop playsinline width="180" style="border-radius:10px;"></video>
</div>

<!-- パート切り替え -->
<div id="partButtons"></div>

<!-- 追加：Part用ページネーション（下） -->
<div class="pagination" id="partPagination"></div>
<!-- これを追加 -->
<div style="text-align:center; margin:6px 0 14px;">
  <button id="swipeStartBtn" onclick="startSwipeMode()">
    スワイプ学習を始める
  </button>
</div>
<div id="swipeModeBox" class="hidden">
  <div class="swipe-hud">
    <button id="swipeExitBtn">一覧に戻る</button>
    <div id="swipeCounter">0 / 0</div>
    <div id="swipeStats" aria-live="polite">覚えた: 0 / 覚えたい: 0</div>
  </div>

  <div id="swipeDeck">
    <!-- ここにカードを重ねて描画 -->
  </div>

  <div class="swipe-hints">
    <span>← 覚えてない</span>
    <span>覚えた →</span>
  </div>
</div>


<div id="statsBox">
  <div id="learningStatus" aria-live="polite"></div>
  <div id="subStats">
    <div id="loginDays"></div>
    <div id="testStats"></div>
  </div>
</div>

<!-- 広告と課金 -->
<div style="margin: 10px;">
  <button onclick="watchAdGlobal()">広告を見て美女が英単語を表現（5枚有効）</button>
</div>
<!-- <div style="margin: 10px;">
  <button onclick="showPremiumPopup()">100円でホットパンツ美女解放</button>
</div> -->

<div id="test-section" style="text-align: center; margin: 30px 0;">
<button id="testStartBtn" onclick="startTest()">テストを開始する</button>
<button id="testStartBtnVocab" onclick="startVocabularyTest()">テストを開始する(単語モード)</button>
  <button onclick="goToPart(getUserId(), '無双Part')">無双Partへ</button>
</div>
<div id="weeklyAnswersBox" style="max-width:700px;margin:20px auto;">
  <h3 style="text-align:center;margin:10px 0;">1週間の解答数:(目標解答数:80が目安)</h3>
  <div id="weeklyBars" style="display:flex;gap:8px;justify-content:space-between;align-items:flex-end;height:140px;padding:8px 4px;background:#fff3f8;border:1px solid #ff99c9;border-radius:12px;"></div>
  <div id="weeklyLabels" style="display:flex;gap:8px;justify-content:space-between;font-size:.8rem;margin-top:6px;color:#555;"></div>
</div>

<div id="wordContainer"></div>
<div class="pagination" id="pagination"></div>
<!-- HTMLの一番下に追加 -->
<div id="videoModal" style="display:none; position:fixed; top:0; left:0; 
  width:100%; height:100%; background-color:rgba(0,0,0,0.8); 
  justify-content:center; align-items:center; z-index:999;">
  <video id="videoPlayer" controls autoplay width="80%"></video>
</div>

<script>
// すべてのfetchを同一オリジン & Cookie付きで
// 一番上の apiFetch を置き換え
const apiFetch = (path, opts = {}) => {
  const method = (opts.method || 'GET').toUpperCase();
  const needsCSRF = !['GET','HEAD','OPTIONS'].includes(method);
  const headers = new Headers(opts.headers || {});
  if (needsCSRF) {
    const m = document.cookie.match(/(?:^|;\s*)_csrf=([^;]+)/);
    const token = m ? decodeURIComponent(m[1]) : null;
    if (token && !headers.has('X-CSRF-Token')) headers.set('X-CSRF-Token', token);
  }
  return fetch(path, { credentials: 'include', ...opts, headers });
};

// JSONしか受け付けないfetch（Cookie付き・非JSONは例外）
async function fetchJSON(url, opts) {
  const res = await apiFetch(url, opts);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const ct = res.headers.get('content-type') || '';
  if (!ct.includes('application/json')) throw new Error('non-json');
  return res.json();
}

// グローバルで使っているのに未宣言だったので用意
let musouMode = false;
let words = [];
let user = { id: null, isPremium: false, canWatchVideo: false };
let currentPage = 1;
const pageSize = 5;
let selectedPart = "part1"; // ← 初期値を設定
let currentPart = 1; // 初期値として Part1 = 1 を設定
const AD_EVERY_TOGGLE = 6;
const AD_EVERY_SWIPE  = 7;

const style = document.createElement('style');
style.innerHTML = `
@keyframes pop {
  0% { transform: scale(0.3); opacity: 0; }
  100% { transform: scale(1); opacity: 1; }
}`;
document.head.appendChild(style);



//表示名と実際のpart名をマッピング
const parts = [
  { label: "Part1", value: "part1" },
  { label: "Part2", value: "part2" },
  { label: "Part3", value: "part3" },
  { label: "Part4", value: "part4" },
  { label: "Part5", value: "part5" },
/*   { label: "Part6", value: "part6" },
  { label: "癒しPart", value: "partHealing" } */
];

document.addEventListener("DOMContentLoaded", async () => {
  await fetchUserInfo();          // サーバのセッションから本人取得
  const userId = user.id;         // 以降必要ならこれを使う

  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get("premium") === "true") {
    await setUserPremium(userId);
    user.isPremium = true;
  }

  renderPartButtons();
  await loadWords();
  refreshUserStats();
  showUpdateInfoIfNeeded();
  ensureHeroVideo();
  placeSwipeBoxAboveStartButton();
});

//URLのテスト結果をUIへ反映し、必要ならコミットも打つ
async function applyTestParamsAndCommit() {
  const sp = new URLSearchParams(location.search);
  const from  = sp.get('from');
  const score = parseInt(sp.get('score') || '0', 10);
  const total = parseInt(sp.get('total') || '0', 10);
  const userId = getUserIdFromQuery() || 1;
  const mode = 'sentence';

  if (from !== 'test' || !total) return;

  // まず画面を即時更新（サーバ遅延してもユーザーは結果を見られる）
  const testStats = document.getElementById("testStats");
  if (testStats) testStats.textContent = `正答数: ${score} / ${total}問中`;

  // レベル演出（暫定）：直近の合計正答をローカルで積み上げ表示
  const localTotalCorrectKey = `localTotalCorrect:${userId}`;
  const prevLocal = parseInt(localStorage.getItem(localTotalCorrectKey) || '0', 10);
  const newLocal  = prevLocal + score;
  localStorage.setItem(localTotalCorrectKey, String(newLocal));

  const prevLevel = Math.floor(prevLocal / 10);
  const newLevel  = Math.floor(newLocal / 10);
  for (let lv = prevLevel + 1; lv <= newLevel; lv++) showLevelUpPopup(lv);

  // すでに test.html 側でコミット済みなら何もしない
  const committedKey = `committed:${userId}:${mode}:${score}/${total}`;
  if (sessionStorage.getItem(committedKey) === '1') return;

  // 未コミットならここでリトライコミット
  try {
   const res = await apiFetch('/api/test/commit', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ mode, correct: score, total }) });
    if (res.ok) {
      sessionStorage.setItem(committedKey, '1');
    } else {
      console.warn('user.html側コミット失敗', res.status);
    }
  } catch (e) {
    console.warn('user.html側コミット例外', e);
  }
}

// 既存の DOMContentLoaded 後や loadWords() 完了後に呼んでOK
document.addEventListener('DOMContentLoaded', () => {
  applyTestParamsAndCommit();
});


//✅ アップデート履歴（例）
const latestUpdateVersion = "1.3.0"; // ← 最新バージョン
const updateMessage = `
  <ul style="text-align: left;">
    <li>🎉 新機能「衣装切り替え」ボタンを追加</li>
    <li>📈 正答数に応じたレベルアップ演出を追加</li>
    <li>🔒 無料ユーザーには一部機能にプレミアム制限</li>
    <li>🐞 軽微なバグ修正とUI改善</li>
  </ul>
`;

// 置き換え
async function headOk(u){
  try{
    const sameOrigin = (() => {
		try { return new URL(u, location.origin).origin === location.origin; }
		catch { return false; }
	})();
    const opt1 = { method: 'HEAD', cache: 'no-store', ...(sameOrigin ? {credentials:'include'} : {}) };
    const r = await fetch(u, opt1);
    if (!r.ok) {
      const opt2 = { method: 'GET', cache: 'no-store', ...(sameOrigin ? {credentials:'include'} : {}) };
      const g = await fetch(u, opt2);
      return g.ok;
    }
    return true;
  }catch{ return false; }
}

async function pickFirstAvailable(list){
  for (const u of list){
    if (await headOk(u)) return u;
  }
  return null;
}

async function ensureHeroVideo(){
  const v = document.getElementById('girlVideo');
  if (!v) return;

  const prefer = (user && (user.premium === true || user.premium === 'true'))
    ? ['/videos/run_girl_motion.mp4'] : [];

  const candidates = [
    ...prefer,
    '/videos/girl_idle_loop.mp4',
    'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/videos/girl_idle_loop.mp4'
  ];

  const ok = await pickFirstAvailable(candidates);
  if (ok){
    v.src = ok;
    try { await v.play(); } catch {}
  }else{
    const p = v.parentElement;
    v.remove();
    const img = document.createElement('img');
    img.src = '/images/beauty.png';
    img.alt = 'girl';
    img.style.borderRadius = '10px';
    img.width = 180;
    p.appendChild(img);
  }
}

	// 追加（どこでもOK、updateLoginPointsIfNeeded より上でも下でも）
function setLoginDays(points){
  const el = document.getElementById('loginDays');
  if (el) el.textContent = `学習日数: ${points}日目`;
}

function isPremium(u = user) {
  return !!(u && (u.premium === true || u.premium === 'true' || u.isPremium === true));
}

// ✅ 初回ログイン or バージョン変更時のみ表示
function showUpdateInfoIfNeeded() {
  const shownVersion = localStorage.getItem("updateInfoShownVersion");
  if (shownVersion !== latestUpdateVersion) {
    Swal.fire({
      title: "✨アップデート情報 (v" + latestUpdateVersion + ")✨",
      html: updateMessage,
      icon: "info",
      confirmButtonText: "閉じる",
      confirmButtonColor: "#e91e63"
    });

    // 表示済みバージョンとして保存
    localStorage.setItem("updateInfoShownVersion", latestUpdateVersion);
  }
}

	
async function checkPremiumStatus(userId) {
	  try {
			const res = await apiFetch(`/user/${encodeURIComponent(userId)}`);
		  	const ct = res.headers.get('content-type') || '';
		    if (!res.ok || !ct.includes('application/json')) return;
	    	const u = await res.json();
	    if (u.premium === true) {
	      // 既存の girlVideo を使用し、存在しない場合はフォールバック
	      const v = document.getElementById("girlVideo");
	      if (v) {
	        const prefer = "/videos/run_girl_motion.mp4";
	        const fallback = "/videos/girl_idle_loop.mp4";
	        v.onerror = () => { v.src = fallback; };
	        v.src = prefer;
	      }
	    }
	  } catch (err) {
	    console.error("ユーザー情報の取得に失敗", err);
	  }
	}

function placeSwipeBoxAboveStartButton(){
  const box = document.getElementById('swipeModeBox');
  const btn = document.getElementById('swipeStartBtn');
  if (!box || !btn) return;
  const wrap = btn.parentElement;                 // ボタンを包む <div ...>
  if (wrap && box.previousElementSibling !== wrap){
    // ボタンの“直前”に #swipeModeBox を移動
    wrap.parentNode.insertBefore(box, wrap);
  }
}
// changePart は selectedPart のみ更新でOK
function changePart(partName) {
  selectedPart = partName;
  const isMusou = (partName === '無双Part');
  musouMode = isMusou;
  if (isMusou) {
    goToPart(undefined, "無双Part");
  } else {
    loadWords();
  }
}


const CDN_BASE = 'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/images';
// 単語からファイル名用スラッグ
function toSlugForImage(s) {
  return (s || "")
    .toLowerCase()
    .trim()
    .replace(/['’`"]/g, "")
    .replace(/\s+/g, "_")
    .replace(/[^a-z0-9_]/g, "");
}

// API 1件をフロントで共通形に正規化
function normalizeWord(raw) {
  const w = {
    id: raw.id ?? raw.wordId ?? raw.word_id ?? raw._id ?? null,   // ← 追加
    word: raw.word ?? "",
    meaning: raw.meaning ?? "",
    part: (raw.part ?? "").toLowerCase(),
    pictUrl: raw.pict_url ?? raw.pictUrl ?? "",
    pictUrlStatic: raw.pict_url_static ?? raw.pictUrlStatic ?? "",
    pictUrlAnimated: raw.pict_url_animated ?? raw.pictUrlAnimated ?? "",
    audioUrl: raw.audio_url ?? raw.audioUrl ?? "",
    videoUrl: raw.video_url ?? raw.videoUrl ?? "",
    status: !!(raw.status ?? raw.learned ?? false),
  };
  w.imageUrl = imageUrlForWord(w);
  return w;
}

// 単語オブジェクトから画像URLを決定（優先順）
function imageUrlForWord(w) {
  return (
    w.pictUrl ||
    w.pictUrlStatic ||
    w.pictUrlAnimated ||
    `/images/${toSlugForImage(w.word)}_girl.png`
  );
}

// 画像404時のフォールバック
function imgTag(src, alt = "") {
  return `<img src="${src}" alt="${alt}"
           width="100"
           onerror="this.onerror=null;this.src='/images/beauty.png';">`;
}

// ▼ 使い方例：取得後に正規化
// const rows = await (await fetch(`/api/words?userId=${uid}&part=part1`)).json();
// const words = rows.map(normalizeWord);

async function uploadAndNormalize(file, mode = "cover") {
  const form = new FormData();
  form.append("file", file);
  const res = await apiFetch(`/api/images/normalize/${mode}`, { method: "POST", body: form });
  if (!res.ok) throw new Error("画像の正規化に失敗");
  return await res.json(); // { url, width, height, mode }
}

async function onFileChange(e, currentWord) {
  const file = e.target.files?.[0];
  if (!file) return;
  const { url } = await uploadAndNormalize(file, "cover");
  // 例：保存APIに反映（実装に合わせて）
  // await fetch(`/api/words/${currentWord.id}`, { method:'PUT', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ pict_url: url }) });
  currentWord.pictUrl = url;
  currentWord.imageUrl = imageUrlForWord(currentWord);
  // 再描画処理…
}

// userId は一切使わず、セッションで本人認可
// 互換のため第1引数は未使用
function goToPart(_unused, partName) {
  location.href = `musou.html?part=${encodeURIComponent(partName)}`;
}

function playAll(wordText) {
  const item = words.find(w => w.word === wordText);
  if (item?.videoUrl) {
    playVideo(item.videoUrl);
  } else {
    Swal.fire({ icon: 'info', text: 'この単語の動画がありません' });
  }
}


function renderWordCard(word, musouMode, user) {
  if (musouMode) {
    return `
      <div class="musou-card">
        <h3>${word.word}（${word.meaning}）</h3>
        ${word.audioUrl ? `<audio controls src="${word.audioUrl}"></audio>` : ""}
        ${word.videoUrl ? `<video controls width="200" src="${word.videoUrl}"></video>` : ""}
        ${imgTag(word.imageUrl, word.word)}
        <button onclick="${user.premium ? `playAll('${word.word}')` : 'showPremiumPopup()'}">美女を動かす</button>
      </div>`;
  } else {
    return `
      <div class="normal-card">
        <strong>${word.word}（${word.meaning}）</strong><br>
        ステータス: <input type="checkbox" ${word.status ? "checked" : ""}>
        <br>
        ${imgTag(word.imageUrl, word.word)}
        <br>
        <button onclick="${user.premium ? `playVideo('${word.videoUrl}')` : 'showPremiumPopup()'}">美女を動かす</button>
      </div>`;
  }
}

function getUserId(){ return user?.id || localStorage.getItem("userId") || "1"; }


function showLevelUpPopup(newLevel) {
	  const title = getTitleByLevel(newLevel);
	  Swal.fire({
	    title: '🎉 LEVEL UP！🎉',
	    html: `
	      <p style="font-size: 20px;">新しいレベル: Lv.${newLevel}</p>
	      <div style="margin-top: 10px;">称号：<strong>${title}</strong></div>
	      <div class="slide-message" style="font-size: 18px; margin-top: 10px;">この調子で頑張ろう！</div>
	      <br>
	      <button id="shareButton" style="background:#1da1f2;color:white;padding:8px 12px;border:none;border-radius:5px;cursor:pointer;">
	        SNSでシェアする
	      </button>
	    `,
	    showConfirmButton: false,
	    timer: 6000,
	    didOpen: () => {
	      document.getElementById("shareButton").addEventListener("click", () => {
	        const shareText = `私は今レベル${newLevel}で「${title}」に到達しました！ #美女単`;
	        const shareUrl = encodeURIComponent("https://your-app-url.com");
	        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(shareText)}&url=${shareUrl}`;
	       	window.open(tweetUrl, '_blank', 'noopener,noreferrer');
	      });
	    }
	  });
	}


//追加：Part用ページング
let partsPage = 1;
const partsPerPage = 4; // 1ページに出すPart数（お好みで）

// 置き換え：ボタンの描画（ページ内のPartだけ表示）
function renderPartButtons() {
  const container = document.getElementById("partButtons");
  container.innerHTML = "";

  const start = (partsPage - 1) * partsPerPage;
  const view = parts.slice(start, start + partsPerPage);

  view.forEach(({ label, value }) => {
    const btn = document.createElement("button");
    btn.textContent = label;
    btn.onclick = () => selectPart(value);
    if (value === selectedPart) btn.style.fontWeight = "bold";
    container.appendChild(btn);
  });

  renderPartPagination(); // ← ページ番号も更新
}

function renderPartPagination() {
  const pageCount = Math.ceil(parts.length / partsPerPage);
  const bottom = document.getElementById("partPagination");
  const containers = [bottom].filter(Boolean); // ← 上は使わない

  containers.forEach(c => { c.innerHTML = ""; });
  if (pageCount <= 1) {
    containers.forEach(c => c.classList.add("hidden"));
    return;
  }
  containers.forEach(c => c.classList.remove("hidden"));

  const build = (wrap) => {
    const makeBtn = (label, page, disabled = false, active = false) => {
      const btn = document.createElement("button");
      btn.textContent = label;
      if (disabled) btn.disabled = true;
      if (active) { btn.classList.add("active"); btn.setAttribute("aria-current","page"); }
      btn.addEventListener("click", () => {
        if (disabled || !page || page === partsPage) return;
        const oldTop = wrap.getBoundingClientRect().top;
        partsPage = page;
        renderPartButtons();
        requestAnimationFrame(() => {
          const newTop = wrap.getBoundingClientRect().top;
          window.scrollBy(0, newTop - oldTop);
        });
      });
      return btn;
    };
    const addPage = (n) => wrap.appendChild(makeBtn(String(n), n, false, n === partsPage));
    const addDots = () => { const s=document.createElement("span"); s.className="ellipsis"; s.textContent="…"; wrap.appendChild(s); };

    wrap.appendChild(makeBtn("‹", partsPage - 1, partsPage === 1));
    if (pageCount <= 5) for (let i=1;i<=pageCount;i++) addPage(i);
    else if (partsPage <= 3){ addPage(1);addPage(2);addPage(3);addDots();addPage(pageCount); }
    else if (partsPage >= pageCount-2){ addPage(1);addDots();addPage(pageCount-2);addPage(pageCount-1);addPage(pageCount); }
    else { addPage(1);addDots();addPage(partsPage-1);addPage(partsPage);addPage(partsPage+1);addDots();addPage(pageCount); }
    wrap.appendChild(makeBtn("›", partsPage + 1, partsPage === pageCount));
  };

  containers.forEach(build);
}

// 修正：Part選択時に「そのPartが載っているページ」を自動表示
function selectPart(part) {
  const lockedParts = ["part4", "part5", "part6", "partHealing", "musou"];
  const isLockedPart = lockedParts.includes(part);

  const show = () => {
    selectedPart = part;
    const idx = Math.max(0, parts.findIndex(p => p.value === part));
    partsPage = Math.floor(idx / partsPerPage) + 1; // そのPartが載っている「Partページ」を表示
    currentPart = idx + 1;
    currentPage = 1;
    renderPartButtons();
    loadWords();
  };

  if (!isPremium() && isLockedPart && !isAdEnabled()) {
    Swal.fire({
      title: "このパートは広告視聴が必要です",
      html: `<p>広告を見れば<strong>5分間だけ開放</strong>されます。<br>
             <span style="color:#e91e63;font-weight:bold;">🎀プレミアム会員</span>なら、<strong>無制限で開放</strong>されます。</p>`,
      icon: "info",
      showCancelButton: true,
      showDenyButton: true,
      confirmButtonText: "広告を見る",
      cancelButtonText: "やめる",
      denyButtonText: "🎀 300円で広告なし！美女めくり放題🎀"
    }).then(result => {
      if (result.isConfirmed) {
        watchAdGlobal();
        show();
      } else if (result.isDenied) {
        showPremiumPopup();
      }
    });
  } else {
    show();
  }
}

// クエリから userId を取る小道具
function getUserIdFromQuery() {
  const p = new URLSearchParams(location.search);
  return p.get('userId');
}

// どこか上の方に追加
async function readJsonIfPossible(res) {
  const ct = (res.headers.get('content-type') || '').toLowerCase();
  if (!ct.includes('application/json')) return null; // HTML等は弾く
  try { return await res.json(); } catch { return null; }
}

async function fetchUserInfo() {
  const uid = getUserIdFromQuery() || localStorage.getItem('userId');

  // 可能性のあるエンドポイントを順に試す
  const candidates = [
    '/user/me',
    ...(uid ? [`/user/${encodeURIComponent(uid)}`] : []),
    '/api/user/me'
  ];

  for (const url of candidates) {
    try {
      const data = await fetchJSON(url);
      user = data;

      localStorage.setItem("userId", String(data.id));
      document.getElementById("username").innerText  = `${data.username} さん、ようこそ！`;
      document.getElementById("planText").innerText  = `プラン: ${data.premium ? "プレミアム" : "無料"}`;
      document.getElementById("userLevel").innerText = `レベル: Lv.${data.level || 1}`;
      updateGirlVisual(data.level || 1);

      // ログボ更新＆表示
      const ok = await updateLoginPointsIfNeeded(data.id);
      if (!ok) {
        const points = (typeof data.loginPoints === 'number') ? data.loginPoints : 1;
        setLoginDays(points);
        showLoginBonusOncePerDay(points);
      }
      return true;
    } catch (e) {
      // 次の候補へ
    }
  }

  // どれもダメ（未ログイン or 非JSON）
  Swal.fire({
    icon: 'warning',
    title: 'ログインが必要です',
    text: 'もう一度ログインしてください。'
  }).then(() => {
    // サーバのログインパスに合わせて片方が効くよう二段構え
    location.href = '/login';
    setTimeout(() => { location.href = 'login.html'; }, 200);
  });
  return false;
}

async function updateLoginPointsIfNeeded(userId) {
  // 候補をいろいろ試す（PUT/GET 両対応）
  const tries = [
    { url: `/user/${encodeURIComponent(userId)}/update-login-points`, method: 'PUT', withBody: true },
    { url: `/api/user/${encodeURIComponent(userId)}/update-login-points`, method: 'PUT', withBody: true },
    { url: `/api/user/update-login-points?userId=${encodeURIComponent(userId)}`, method: 'PUT', withBody: false },
    { url: `/api/user/update-login-points?userId=${encodeURIComponent(userId)}`, method: 'GET', withBody: false },
    { url: `/user/update-login-points?userId=${encodeURIComponent(userId)}`, method: 'GET', withBody: false },
  ];

  for (const t of tries) {
    try {
      const res = await apiFetch(t.url, {
        method: t.method,
        headers: t.withBody ? { 'Content-Type': 'application/json' } : undefined,
        body: t.withBody ? JSON.stringify({ userId }) : undefined
      });
      if (res.ok) {
        const updated = await res.json().catch(() => null);
        const points = (updated && typeof updated.loginPoints === 'number') ? updated.loginPoints : undefined;
        if (typeof points === 'number') {
          setLoginDays(points);
          showLoginBonusOncePerDay(points);
        }
        return true;
      }
      if (res.status !== 404) return false; // 404以外はそこで終了
    } catch (_) { /* 次の候補へ */ }
  }

  // ---- フォールバック：/user → /api/test/weekly ----
  try {
    const uRes = await apiFetch(`/user/${encodeURIComponent(userId)}`);
    if (uRes.ok) {
      const u = await uRes.json();
      if (typeof u.loginPoints === 'number') {
        setLoginDays(u.loginPoints);
        showLoginBonusOncePerDay(u.loginPoints);
        return true;
      }
    }
  } catch {}

  try {
    const wRes = await apiFetch(`/api/test/weekly?userId=${encodeURIComponent(userId)}`);
    if (wRes.ok) {
      const w = await wRes.json();
      const days = Array.isArray(w) ? w.filter(d => (d.answers ?? 0) > 0).length : 0;
      const points = Math.max(1, days); // 少なくとも1日目表示
      setLoginDays(points);
      showLoginBonusOncePerDay(points);
      return true;
    }
  } catch {}

  console.warn('update-login-points endpoint が見つかりませんでした');
  return false;
}

// 1日1回だけポップアップ
function showLoginBonusOncePerDay(points){
  const d = new Date();
  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
  const key = `loginBonusShown:${ymd}`;
  if (localStorage.getItem(key) === '1') return;
  showLoginBonus(points);
  localStorage.setItem(key, '1');
}



// セッションで本人認可。userId は一切送らない
async function fetchWordsFromServer(part) {
  const tries = [
    `/api/words?part=${encodeURIComponent(part)}`,
    `/words?part=${encodeURIComponent(part)}`
  ];

  for (const url of tries) {
    try {
      const res = await apiFetch(url, { headers:{ 'Accept':'application/json' } });
      if (res.ok) {
        const data = await readJsonIfPossible(res);
		if (!Array.isArray(data)) continue;
        console.log('words fetched from', url, 'count=', data.length);
        return data.map(w => {
          const s = w.status ?? w.learned;
          const learned =
            s === true || s === 1 || s === '1' || s === 'true' || s === 'LEARNED';
          return normalizeWord({ ...w, status: !!learned });
        });
      }
      if (res.status !== 404) {
        console.error('words fetch failed', res.status, await res.text().catch(() => ''));
        break;
      }
    } catch (_) {
      // 次の候補へ
    }
  }

  alert('単語の取得に失敗しました（エンドポイント未検出）');
  return [];
}



//=== 広告表示トリガ用のカウンタと保留実行 ===
let pendingToggle = null;

function getBeautyClickCount() {
  const n = parseInt(localStorage.getItem('beauty_clicks') || '0', 10);
  return isNaN(n) ? 0 : n;
}
function incBeautyClickCount() {
  const n = getBeautyClickCount() + 1;
  localStorage.setItem('beauty_clicks', String(n));
  return n;
}
function resetBeautyClickCount() {
  localStorage.setItem('beauty_clicks', '0');
}

// 広告モーダルを開いて、閉じたら処理再開できるように保留
function showAdModalForToggle(callback) {
  pendingToggle = callback;
  document.getElementById('adModal').style.display = 'flex';
}

// 既存のモーダルのボタンIDに対応（下のモーダルHTMLそのまま使えます）
function handleAdAccept() {
  // 視聴処理（既存の5分解放を流用）
  watchAdGlobal();
  closeAdModal();
  if (typeof pendingToggle === 'function') {
    pendingToggle();
    pendingToggle = null;
  }
  resetBeautyClickCount(); // 6回カウントをリセット
}
function closeAdModal() {
  document.getElementById('adModal').style.display = 'none';
  pendingToggle = null;
}


// スクリプト上部のどこか（他関数の外）に置く
function esc(s=''){
  return String(s)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}

function safeSrc(u, { allowDataImage=false } = {}){
	try{
	const url = new URL(u, location.origin);
	const okHttp = url.protocol === 'http:' || url.protocol === 'https:';
	const okData = allowDataImage && url.protocol === 'data:';
	return (okHttp || okData) ? url.href : '/images/beauty.png';
	} catch { return '/images/beauty.png'; }
}
	
function escHTML(v=''){ return String(v)
  .replace(/&/g,'&amp;').replace(/</g,'&lt;')
  .replace(/>/g,'&gt;').replace(/"/g,'&quot;')
  .replace(/'/g,'&#39;'); }

function h(parts, ...vals){
  return parts.reduce((s, p, i) => s + p + (i < vals.length ? escHTML(vals[i]) : ''), '');
}

function renderWords() {
  const container = document.getElementById("wordContainer");
  container.innerHTML = "";

  const start = (currentPage - 1) * pageSize;
  const pageWords = words.slice(start, start + pageSize);

  pageWords.forEach((word, index) => {
    const div = document.createElement("div");
    div.className = "word-card";

    const isPremium = !!(user && (user.premium === true || user.premium === 'true'));
    const actionButton = ""; // 無料は非表示

    const checkboxId = `status-${word.id}`;
    const checked = word.status ? "checked" : "";
    const labelText = word.status ? "学習済み" : "未学習";

    const imageId = `img-${index}`;
    const toggleButtonId = `toggle-${index}`;
    const baseImg = '/images/beauty.png';
    const slug = toSlugForImage(word.word);
    const specificImg = `/images/${slug}_girl.png`;

    const stateKey  = `imgState:${word.id}`;
    const initState = localStorage.getItem(stateKey) || '1';
   	const initSrc = safeSrc((initState === '2') ? specificImg : baseImg, { allowDataImage:true });


    div.innerHTML = `
      <div class="wc-img">
        <img
          id="${imageId}"
          src="${initSrc}"
          alt="${esc(word.word)}"
          loading="lazy"
		  width="88"
	      height="132"
          decoding="async"
          draggable="false"
          data-state="${initState}"
          data-word-id="${word.id}"
          onerror="this.onerror=null;this.src='${baseImg}';this.dataset.state='1';document.getElementById('imgpath-${index}').textContent='${baseImg}';localStorage.setItem('${stateKey}','1');"
        >
      </div>

      <div class="wc-body">
        <strong>${esc(word.word)}</strong>
        <div class="meta">（${esc(word.meaning)}）</div>
        <div class="meta">
          ステータス:
        <input type="checkbox" id="${checkboxId}" ${checked}
		  data-word-id="${word.id}"
		  data-part="${esc(selectedPart)}">
          <span id="status-label-${word.id}">${labelText}</span>
        </div>
        <div class="meta">画像パス: <span id="imgpath-${index}">${initSrc}</span></div>
      </div>

<div class="wc-actions">
    <!-- 画像トグル用 -->
    <button
      type="button"
      class="js-toggle"
      id="${toggleButtonId}"
      data-img-id="${imageId}"
      data-base="${esc(baseImg)}"
      data-specific="${esc(specificImg)}"
      data-index="${index}"
      aria-controls="${imageId}"
      aria-pressed="${initState === '2' ? 'true' : 'false'}"
    >美女で英単語を表現する</button>

    <!-- 動画再生（ある場合だけ） -->
    ${word.videoUrl ? `
      <button
        type="button"
        class="js-play"
        data-video="${esc(word.videoUrl)}"
      >動画を見る</button>` : ``}

    ${actionButton ? `<div style="margin-top:6px">${actionButton}</div>` : ""}
  </div>
	    `;
    container.appendChild(div);
  }); // ← ここが抜けてました！

  renderPagination(words.length);
}

let _delegationReady = false;
function setupWordDelegation(){
  if (_delegationReady) return;
  _delegationReady = true;

  const root = document.getElementById("wordContainer");

  root.addEventListener("click", (e) => {
    const tgl = e.target.closest("button.js-toggle");
    if (tgl) {
      const { imgId, base, specific, index } = tgl.dataset;
      handleToggleImage(imgId, tgl.id, base, specific, index);
      return;
    }
    const play = e.target.closest("button.js-play");
    if (play) {
      const url = safeSrc(play.dataset.video);
      if (url) playVideo(url);
    }
  });

  root.addEventListener("change", (e) => {
    const cb = e.target.closest('input[type="checkbox"][data-word-id]');
    if (!cb) return;
    toggleStatus(cb.checked, Number(cb.dataset.wordId), cb.dataset.part);
  });
}

// DOMContentLoaded 後 or renderWords() の直後に一回だけ
document.addEventListener("DOMContentLoaded", setupWordDelegation);




function toggleImage(imgId, btnId, img1, img2, index) {
  const imgElem   = document.getElementById(imgId);
  const pathLabel = document.getElementById(`imgpath-${index}`);
  const btn       = document.getElementById(btnId);
  const wordId    = imgElem?.dataset?.wordId;
  const stateKey  = wordId ? `imgState:${wordId}` : null;

  // 現在の状態は data-state（'1' or '2'）
  const nextState = (imgElem.dataset.state === '2') ? '1' : '2';
  const nextSrc   = (nextState === '2') ? img2 : img1;

  const test = new Image();
  test.onload = () => {
    imgElem.src = nextSrc;
    imgElem.dataset.state = nextState;
    if (pathLabel) pathLabel.textContent = nextSrc;
    if (btn) btn.setAttribute('aria-pressed', nextState === '2' ? 'true' : 'false');
    if (stateKey) localStorage.setItem(stateKey, nextState);
  };
  test.onerror = () => {
    imgElem.src = img1;
    imgElem.dataset.state = '1';
    if (pathLabel) pathLabel.textContent = img1;
    if (btn) btn.setAttribute('aria-pressed', 'false');
    if (stateKey) localStorage.setItem(stateKey, '1');
  };
  test.src = nextSrc;
}



function handleToggleImage(imgId, btnId, img1, img2, index) {
  const proceed = () => toggleImage(imgId, btnId, img1, img2, index);
  const total = incBeautyClickCount();
if (!isPremium() && AD_EVERY_TOGGLE > 0 && total % AD_EVERY_TOGGLE === 0) {
    showAdModalForToggle(proceed);
    return;
  }
  proceed();
}

function renderPagination(totalItems) {
  const pageCount = Math.ceil(totalItems / pageSize);
  const bottom = document.getElementById("pagination");
  const containers = [bottom].filter(Boolean); // ← 上は使わない

  containers.forEach(c => c.innerHTML = "");
  if (pageCount <= 1) return;

  const build = (wrap) => {
    const makeBtn = (label, page, disabled = false, active = false) => {
      const btn = document.createElement("button");
      btn.textContent = label;
      if (disabled) btn.disabled = true;
      if (active) btn.classList.add("active");
      btn.addEventListener("click", () => {
        if (disabled || !page || page === currentPage) return;
        const oldTop = wrap.getBoundingClientRect().top;
        currentPage = page;
        renderWords();
        requestAnimationFrame(() => {
          const newTop = wrap.getBoundingClientRect().top;
          window.scrollBy(0, newTop - oldTop);
        });
      });
      return btn;
    };
    const addPage = (n) => wrap.appendChild(makeBtn(String(n), n, false, n === currentPage));
    const addDots = () => { const s=document.createElement("span"); s.className="ellipsis"; s.textContent="…"; wrap.appendChild(s); };

    wrap.appendChild(makeBtn("‹", currentPage - 1, currentPage === 1));
    if (pageCount <= 5) for (let i=1;i<=pageCount;i++) addPage(i);
    else if (currentPage <= 3){ addPage(1);addPage(2);addPage(3);addDots();addPage(pageCount); }
    else if (currentPage >= pageCount-2){ addPage(1);addDots();addPage(pageCount-2);addPage(pageCount-1);addPage(pageCount); }
    else { addPage(1);addDots();addPage(currentPage-1);addPage(currentPage);addPage(currentPage+1);addDots();addPage(pageCount); }
    wrap.appendChild(makeBtn("›", currentPage + 1, currentPage === pageCount));
  };

  containers.forEach(build);
}


// 置き換え
async function loadWords() {
  words = await fetchWordsFromServer(selectedPart);  // ← userIdを渡さない
  renderWords();

  updateStatusCount();

  document.getElementById("loginDays").textContent =
    `学習日数: ${user.loginPoints || 0}日目`;

  const correct = localStorage.getItem("test_correct") || 0;
  const total = localStorage.getItem("test_total") || 0;
  document.getElementById("testStats").textContent = `正答数: ${correct} / ${total}問中`;

  await refreshUserStats();
}


function watchAdGlobal() {
	  const now = Date.now();
	  const expiry = now + 5 * 60 * 1000; // 5分間有効
	  localStorage.setItem("ad_expiry", expiry.toString());

	  alert("広告視聴完了！");
	  renderWords(); // ← ボタン表示を即時反映
	}
	
function isAdEnabled() {
	  const expiry = localStorage.getItem("ad_expiry");
	  return expiry && Date.now() < parseInt(expiry);
	}


function unlockCasualSuit() {
  alert("1000円で美女スーツ解放（仮）");
}

function playVideo(videoUrl) {
  const url = safeSrc(videoUrl);
  if (!url) return;
  const modal = document.getElementById("videoModal");
  const player = document.getElementById("videoPlayer");
  player.src = url;
  modal.style.display = "flex";
  const stop = e => e.stopPropagation();
  player.addEventListener('click', stop);
  modal.onclick = () => {
    modal.style.display = "none";
    player.pause();
    player.currentTime = 0;
    player.removeEventListener('click', stop);
  };
}

	
// 置き換え
function updateGirlVisual(level) {
  const v = document.getElementById("girlVideo");
  const bg = document.getElementById("bgEffect");
  if (!v || !bg) return;

  // srcは原則いじらない。空ならだけ初期値を入れる
  if (!v.getAttribute('src')) {
    v.src = '/videos/girl_idle_loop.mp4';
  }
  // 404時はCDNにフォールバック
  v.onerror = () => {
    v.onerror = null;
    v.src =
      'https://cdn.jsdelivr.net/gh/masahirotabata/bijyotan@master/src/main/resources/static/videos/girl_idle_loop.mp4';
  };

  bg.className = level >= 20 ? "heart-bg" : "star-bg";
}



function toggleStatus(isChecked, wordId, part) {
  apiFetch('/api/learning/update', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    // userId は送らない（サーバでセッション認可）
    body: JSON.stringify({ wordId, status: isChecked, part })
  })
  .then(response => {
    if (!response.ok) {
      alert("更新に失敗しました");
      return;
    }

    // 成功時のみフロント状態を反映
    const w = words.find(w => w.id === wordId);
    if (w) {
      w.status = isChecked;
      const statusSpan = document.getElementById(`status-label-${wordId}`);
      if (statusSpan) {
        statusSpan.innerText = isChecked ? "学習済み" : "未学習";
      }
    }

    updateStatusCount();
  })
  .catch(err => {
    console.error(err);
    alert("通信エラーが発生しました");
  });
}

// 置き換え
async function updateStatusCount() {
  const tries = [
    `/api/learning/count?part=${encodeURIComponent(selectedPart)}`,
    `/learning/count?part=${encodeURIComponent(selectedPart)}`
  ];

  for (const url of tries) {
    try {
      const res = await apiFetch(url);
      if (res.ok) {
        const learnedCount = await res.json();
        const totalCount = words.length;
        const unlearnedCount = Math.max(0, totalCount - learnedCount);
        document.getElementById("learningStatus").textContent =
          `学習済み: ${learnedCount} / 未学習: ${unlearnedCount}`;
        return;
      }
      if (res.status !== 404) break;
    } catch (_) {}
  }
  document.getElementById("learningStatus").textContent = "学習状況の取得に失敗しました";
}


//置き換え版：数値ラベルを表示
async function loadWeeklyAnswers(){
  try{
    const res = await apiFetch('/api/test/weekly');
    const ct = res.headers.get('content-type') || '';
    if (!res.ok || !ct.includes('application/json')) {
      console.warn('weekly endpoint returned non-JSON, skip');
      return;
    }
    const data = await res.json(); // [{ymd, answers, correct}, ...]
    const max = Math.max(1, ...data.map(d => d.answers));
    const bars = document.getElementById('weeklyBars');
    const labels = document.getElementById('weeklyLabels');
    bars.innerHTML = ''; labels.innerHTML = '';
    data.forEach(d => {
      const h = Math.round((d.answers / max) * 120);
      const wrap = document.createElement('div');
      wrap.style.flex = '1';
      wrap.style.display = 'flex';
      wrap.style.flexDirection = 'column';
      wrap.style.alignItems = 'center';
      wrap.style.justifyContent = 'flex-end';

      const num = document.createElement('div');
      num.textContent = d.correct;
      num.style.fontSize = '.8rem';
      num.style.color = '#e91e63';
      num.style.marginBottom = '4px';
      wrap.appendChild(num);

      const bar = document.createElement('div');
      bar.title = `正解:${d.correct} / 解答:${d.answers}`;
      bar.style.width = '24px';
      bar.style.height = `${h}px`;
      bar.style.borderRadius = '8px';
      bar.style.background = 'linear-gradient(180deg,#ff7bbd,#ffb3d9)';
      bar.style.boxShadow = '0 2px 6px rgba(0,0,0,.08)';
      wrap.appendChild(bar);

      bars.appendChild(wrap);

      const dd = new Date(d.ymd);
      const label = document.createElement('div');
      const mm = String(dd.getMonth()+1).padStart(2,'0');
      const ddn = String(dd.getDate()).padStart(2,'0');
      const youbi = ['日','月','火','水','木','金','土'][dd.getDay()];
      label.style.flex='1';
      label.style.textAlign='center';
      label.innerHTML = `<div>${mm}/${ddn}</div><div style="opacity:.7">${youbi}</div>`;
      labels.appendChild(label);
    });
  }catch(e){
    console.warn('weekly chart load failed', e);
  }
}



	// DOMContentLoaded 後のどこかで呼ぶ
	document.addEventListener("DOMContentLoaded", loadWeeklyAnswers);


// フォーカストラップ
function trapFocus(modal){
  const SEL = 'a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])';
  const getNodes = ()=> Array.from(modal.querySelectorAll(SEL)).filter(el=>!el.disabled && el.offsetParent!==null);
  function onKeydown(e){
    if (e.key !== 'Tab') return;
    const nodes = getNodes(); if (!nodes.length) return;
    const first = nodes[0], last = nodes[nodes.length-1];
    if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
  }
  modal.addEventListener('keydown', onKeydown);
  return ()=> modal.removeEventListener('keydown', onKeydown);
}

// 例：ログインボーナス
let removeTrapLoginBonus = null;
function showLoginBonus(points){
  /* ...既存... */
  const popup = document.getElementById('loginBonusPopup');
  popup.setAttribute('role','dialog');
  popup.setAttribute('aria-modal','true');
  popup.setAttribute('aria-labelledby','loginBonusTitle');
  popup.style.display = 'flex';
  removeTrapLoginBonus = trapFocus(popup);
  popup.querySelector('button, [href], [tabindex]:not([tabindex="-1"])')?.focus();
  document.body.classList.add('modal-open');
}
function closeLoginBonus(){
  const popup = document.getElementById('loginBonusPopup');
  popup.style.display = 'none';
  removeTrapLoginBonus?.();
  document.body.classList.remove('modal-open');
}


	
function getTitleByLevel(level) {
		  if (level >= 20) return "ホットパンツの覇者";
		  if (level >= 15) return "セクシー学習王";
		  if (level >= 10) return "フリフリ美女マスター";
		  if (level >= 5) return "Newbie";
		  return "ビギナー";
}
	
function showPremiumPopup() {
  Swal.fire({
    title: '🎀 美女単プレミアムプラン 🎀',
    html: `
      <div style="text-align:left; font-size: 0.95rem;">
        <p>全モード解放＆広告なしの贅沢体験</p>
        <ul style="line-height:1.6;">
          <li>✔ リスニングモード解放</li>
          <li>✔ テスト回数無制限＆成績履歴も保存</li>
        </ul>
        <p style="font-weight:bold; font-size:1.1rem;">💰 月額500円（税込）</p>
        <p style="color:red;">✨ 今だけ初月300円キャンペーン中 ✨</p>
        <small>SNSでシェアすると1週間無料体験🎁</small>
      </div>
    `,
    showCancelButton: true,
    confirmButtonText: "プレミアムに登録する",
    cancelButtonText: "あとで見る",
    customClass: {
      popup: 'premium-popup',
      confirmButton: 'btn-premium'
    }
  }).then(async (result) => {
    if (result.isConfirmed) {
      // ここでチェックアウトセッションを作ってリダイレクト
      try {
        const r = await apiFetch('/api/payment/create-checkout-session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          // セッション認証なら userId 不要。サーバ仕様に合わせて必要なら付与
          body: JSON.stringify({ /* userId: getUserId() */ })
        });
        const data = await r.json();
        if (data && data.checkoutUrl) {
          window.location.href = data.checkoutUrl;
        } else {
          // フォールバック
          window.location.href = "/premium.html";
        }
      } catch (e) {
        console.error(e);
        window.location.href = "/premium.html";
      }
    }
  });
}
	
apiFetch('/api/payment/create-checkout-session', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ userId: getUserId() }) })
	  .then(res => res.json())
	  .then(data => { window.location.href = data.checkoutUrl; })
	  .catch(console.error);
	}
	



	function startTest() {
		  const userId = getUserId();  
		  const testCount = localStorage.getItem("test_started");

		  if (testCount) {
		    alert("広告を見せる処理（仮）");
		  }

		  if (user.premium) {
		    // プレミアムユーザーはモード選択可能
		    Swal.fire({
		      title: "テストモードを選んでね",
		      html: `
		        <button id="readingBtn" class="swal2-confirm swal2-styled" style="margin: 5px;">📘 リーディング</button>
		        <button id="listeningBtn" class="swal2-confirm swal2-styled" style="background:#3949ab;margin: 5px;">🎧 リスニング</button>
		      `,
		      showConfirmButton: false,
		      didOpen: () => {
		        document.getElementById("readingBtn").addEventListener("click", () => {
		          localStorage.setItem("test_started", "1");
		          window.location.href = `test.html?userId=${userId}&mode=reading`;
		        });
		        document.getElementById("listeningBtn").addEventListener("click", () => {
		          localStorage.setItem("test_started", "1");
		          window.location.href = `test.html?userId=${userId}&mode=listening`;
		        });
		      }
		    });
		  } else {
		    // 無料ユーザーはリーディングのみ（広告付き）
		    Swal.fire({
		      title: "リスニングモードはプレミアム専用🎧",
		      html: `
		        <p>今は <strong>リーディングモード</strong>のみご利用いただけます。</p>
		        <p>🎀 プレミアム登録で <strong>音声リスニングテスト</strong>も可能に！</p>
		      `,
		      showCancelButton: true,
		      confirmButtonText: "リーディングで始める",
		      cancelButtonText: "プレミアムを見る",
		    }).then(result => {
		      if (result.isConfirmed) {
		        localStorage.setItem("test_started", "1");
		        window.location.href = `test.html?userId=${userId}&mode=reading`;
		      } else if (result.dismiss === Swal.DismissReason.cancel) {
		        showPremiumPopup(); // プレミアム案内を表示
		      }
		    });
		  }
		}
	
	function startVocabularyTest() {
		  const userId = getUserId();
		  const testCount = localStorage.getItem("test_started");

		  if (testCount) {
		    alert("広告を見せる処理（仮）");
		  }

		  if (user.premium) {
		    // プレミアムユーザーはモード選択可能
		    Swal.fire({
		      title: "テストモードを選んでね",
		      html: `
		        <button id="readingBtn" class="swal2-confirm swal2-styled" style="margin: 5px;">📘 リーディング</button>
		        <button id="listeningBtn" class="swal2-confirm swal2-styled" style="background:#3949ab;margin: 5px;">🎧 リスニング</button>
		      `,
		      showConfirmButton: false,
		      didOpen: () => {
		        document.getElementById("readingBtn").addEventListener("click", () => {
		          localStorage.setItem("test_started", "1");
		          window.location.href = `vocabularyTest.html?userId=${userId}&mode=reading`;
		        });
		        document.getElementById("listeningBtn").addEventListener("click", () => {
		          localStorage.setItem("test_started", "1");
		          window.location.href = `vocabularyTest.html?userId=${userId}&mode=listening`;
		        });
		      }
		    });
		  } else {
		    // 無料ユーザーはリーディングのみ（広告付き）
		    Swal.fire({
		      title: "リスニングモードはプレミアム専用🎧",
		      html: `
		        <p>今は <strong>リーディングモード</strong>のみご利用いただけます。</p>
		        <p>🎀 プレミアム登録で <strong>音声リスニングテスト</strong>も可能に！</p>
		      `,
		      showCancelButton: true,
		      confirmButtonText: "リーディングで始める",
		      cancelButtonText: "プレミアムを見る",
		    }).then(result => {
		      if (result.isConfirmed) {
		        localStorage.setItem("test_started", "1");
		        window.location.href = `vocabularyTest.html?userId=${userId}&mode=reading`;
		      } else if (result.dismiss === Swal.DismissReason.cancel) {
		        showPremiumPopup(); // プレミアム案内を表示
		      }
		    });
		  }
		}


	// 累計正答と学習日数を /user/{id} から更新。
	// loginPoints がなければ /api/test/weekly から直近7日の「回答>0日数」を表示。
	async function refreshUserStats() {
  try {
    const res = await apiFetch(`/user/me`);
    const ct = res.headers.get('content-type') || '';
    if (!res.ok || !ct.includes('application/json')) throw new Error('non-json');
    const u = await res.json();

    // 学習日数
    const days = (typeof u.loginPoints === 'number') ? u.loginPoints : 0;
    document.getElementById("loginDays").textContent = `学習日数: ${days}日目`;

    // 累計正答 → レベル更新
    const totalCorrect = Number(u.testCorrectTotal ?? 0);
    document.getElementById("testStats").textContent = `正答数（累計）: ${totalCorrect}`;

    const newLevel = Math.max(1, Math.floor(totalCorrect / 10) + 1);
    const currentLevel = Number(u.level ?? 1);
    if (currentLevel !== newLevel) {
      const userId = getUserId(); // ← 追加
      const r = await apiFetch(`/user/updateLevel`, {
        method:'PUT',
        headers:{ 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, level: newLevel })
      });
      if (r.ok) {
        const json = await r.json().catch(() => ({}));
        u.level = Number(json.level ?? newLevel);
      } else {
        u.level = newLevel;
      }
    }
    const levelEl = document.getElementById("userLevel");
    const lv = Number(u.level ?? 1);
    if (levelEl) levelEl.textContent = `レベル: Lv.${lv}`;
    updateGirlVisual(lv);

    // レベル演出
    const prev = parseInt(localStorage.getItem('previousCorrect') || '0', 10);
    const prevLv = Math.floor(prev / 10);
    const newLv  = Math.floor(totalCorrect / 10);
    if (newLv > prevLv) {
      for (let lv2 = prevLv + 1; lv2 <= newLv; lv2++) showLevelUpPopup(lv2);
    }
    localStorage.setItem('previousCorrect', String(totalCorrect));
    return;
  } catch (e) {
    console.warn('refreshUserStats /user fetch failed', e);
  }

  // フォールバック
  try {
    const r2 = await apiFetch('/api/test/weekly');
    if (r2.ok) {
      const w = await r2.json();
      const days = w.filter(d => d.answers > 0).length;
      document.getElementById("loginDays").textContent = `学習日数(直近7日): ${days}日`;
    }
  } catch {}
}

async function setUserPremium(userId) {
  try {
    const res = await apiFetch(`/api/user/updatePremium`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ userId })
    });
    if (!res.ok) throw new Error("更新に失敗");
    console.log("✅ プレミアム状態をDBに反映しました");
  } catch (err) {
    console.error("❌ プレミアム設定失敗:", err);
  }
}

	
	// ===== スワイプ学習モード =====
	let swipeWords = [];      // 今のパートの単語配列（スワイプ用）
	let swipeIndex = 0;       // 先頭から何枚目か
	let swipeLearned = 0;     // このセッションで「覚えた」にした数
	let swipeUnlearned = 0;   // このセッションで「覚えてない」にした数
	let swipeDrag = null;     // {startX, startY, el}
	// 既存のスワイプ用変数の近くに追加
	let currentSwipeMode = "unlearned"; // 'unlearned' or 'review'
	const SWIPE_THRESHOLD = 80; // 何px以上で確定とみなす
	
	// 🔸 今日の日付キー
	function swipeTodayKey(userId){
	  const d = new Date();
	  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
	  return `swipeExcluded:${userId}:${ymd}`;   // 例: swipeExcluded:1:2025-08-24
	}
	
	function todayKey(type){
		  const d = new Date();
		  const ymd = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
		  return `swipe:${type}:${getUserId()}:${ymd}`;
		}

		function getTodaySet(type){
		  const raw = localStorage.getItem(todayKey(type));
		  return new Set(raw ? JSON.parse(raw) : []);
		}

		function addTodaySet(type, wordId){
		  const set = getTodaySet(type);
		  set.add(wordId);
		  localStorage.setItem(todayKey(type), JSON.stringify([...set]));
		}


	// 🔸 今日の除外セットを取得 / 追加保存
	function getSwipeExcludedSet(userId){
	  // 日付が変わったら自動的にリセット（キーも変わる）
	  const raw = localStorage.getItem(swipeTodayKey(userId));
	  return new Set(raw ? JSON.parse(raw) : []);
	}
	function addToSwipeExcluded(userId, wordId){
	  const key = swipeTodayKey(userId);
	  const set = getSwipeExcludedSet(userId);
	  set.add(wordId);
	  localStorage.setItem(key, JSON.stringify([...set]));
	}
	
function setSwipeModeVisible(show){
  const box = document.getElementById('swipeModeBox');
  box.classList.toggle('hidden', !show);

  // 一覧系を隠す/戻す（既存）
  document.getElementById('wordContainer').classList.toggle('hidden', show);
  document.getElementById('pagination').classList.toggle('hidden', show);
  document.getElementById('test-section').classList.toggle('hidden', show);
  document.getElementById('weeklyAnswersBox').classList.toggle('hidden', show);

  // ★ スマホだけ全画面
  const isMobile = window.matchMedia('(max-width:480px)').matches;
  if (show && isMobile){
    box.classList.add('fullscreen');
    document.body.classList.add('swipe-open');
    requestAnimationFrame(resizeSwipeDeck); // 後述
  }else{
    box.classList.remove('fullscreen');
    document.body.classList.remove('swipe-open');
  }
}

function resizeSwipeDeck(){
  const box = document.getElementById('swipeModeBox');
  const deck = document.getElementById('swipeDeck');
  if (!box || !deck) return;
  // グリッドで1frにしているので明示指定は不要だが、
  // iOSの一部で高さが足りなく見える時の保険として最低高さだけ与える
  const h = Math.max(320, box.clientHeight - 96); // だいたいHUD+ヒントぶん
  deck.style.minHeight = h + 'px';
}
window.addEventListener('resize', () => {
  if (!document.getElementById('swipeModeBox').classList.contains('hidden')) {
    resizeSwipeDeck();
  }
});



	// ✅ スワイプ学習開始時：最初に広告 → 終了後モード選択
	function startSwipeMode(partValue = selectedPart){
	  placeSwipeBoxAboveStartButton();   // ← 追加
	  selectedPart = partValue;

	  const lockedParts = ["part4", "part5", "part6", "partHealing", "musou"];
	  const isLocked = lockedParts.includes(selectedPart);
	  if(!user.premium && isLocked && !isAdEnabled()){
	    showPremiumPopup();
	    return;
	  }

	  // ✅ 開始時に広告表示
	  Swal.fire({
	    title: "美女スワイプ学習🎀",
	    html: "「学習開始前と終了時に広告が表示されます（計2回）<br>美女と一緒に楽しく学習しましょう！」",
	    icon: "info",
	    confirmButtonText: "広告を見る",
	    confirmButtonColor: "#e91e63",
	    allowOutsideClick: false
	  }).then(() => {
	    // 実際に広告表示（ここでAdMob等の動画広告を再生する）
	    watchAdGlobal();

	    // 終了後にモード選択へ
	    showSwipeModeSelection();
	  });
	}

	// ✅ モード選択ダイアログ（分離して使いやすく）
	function showSwipeModeSelection() {
	  Swal.fire({
	    title: "モードを選んでね",
	    html: `
	      <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
	        <button id="btnUnlearned" class="swal2-confirm swal2-styled">未学習を覚える</button>
	        <button id="btnReview" class="swal2-confirm swal2-styled" style="background:#3949ab">復習チェック</button>
	      </div>
	    `,
	    showConfirmButton: false,
	    didOpen: () => {
	      document.getElementById("btnUnlearned").onclick = () => {
	        currentSwipeMode = "unlearned";
	        Swal.close();
	        initSwipeMode("unlearned");
	      };
	      document.getElementById("btnReview").onclick = () => {
	        currentSwipeMode = "review";
	        Swal.close();
	        initSwipeMode("review");
	      };
	    }
	  });
	}

function scrollToSwipeTop(){
  const box = document.getElementById('swipeModeBox');
  if (!box) return;
  box.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

/* A) 横方向のタッチ移動は既定動作を止める（iOS対策） */
function preventIOSBackSwipe(){
  const deck = document.getElementById('swipeDeck');
  if (!deck || deck._iosGuardInstalled) return;
  let sx = 0, sy = 0;
  deck.addEventListener('touchstart', e => {
    const t = e.touches && e.touches[0];
    if (!t) return;
    sx = t.clientX; sy = t.clientY;
  }, {passive:true});
  deck.addEventListener('touchmove', e => {
    const t = e.touches && e.touches[0];
    if (!t) return;
    const dx = Math.abs(t.clientX - sx);
    const dy = Math.abs(t.clientY - sy);
    if (dx > dy && dx > 8) {
      // 横方向の操作っぽい時だけ既定動作をキャンセル
      e.preventDefault();
    }
  }, {passive:false});
  deck._iosGuardInstalled = true;
}

/* B) スワイプ中だけ“戻るジェスチャー”を捕まえて一覧に戻す */
// これを1箇所に集約
let _ignoreNextPop = false;
let _backGuardHandler = null;

function enableSwipeBackGuard(){
  if (_backGuardHandler) return;
  history.pushState({swipe:'on'}, '');
  _backGuardHandler = () => {
    if (_ignoreNextPop) { _ignoreNextPop=false; return; }
    history.pushState({swipe:'on'}, '');
    exitSwipeMode();
  };
  window.addEventListener('popstate', _backGuardHandler);
}

function disableSwipeBackGuard(){
  if(!_backGuardHandler) return;
  window.removeEventListener('popstate', _backGuardHandler);
  _backGuardHandler = null;
}

function exitSwipeMode(){
  setSwipeModeVisible(false);
  renderWords();
  updateStatusCount();
  disableSwipeBackGuard();
  if (!isPremium()) watchAdGlobal();
  // ダミー履歴を1つ戻す（実ページ遷移は抑止）
  _ignoreNextPop = true; history.back();
}


async function initSwipeMode(mode = "unlearned"){
  currentSwipeMode = mode;
  setSwipeModeVisible(true);
  showSwipeHowToIfNeeded(); // setSwipeModeVisible(true) の直後など
  requestAnimationFrame(scrollToSwipeTop);  // ← 追加

  const userId = getUserIdFromQuery() || 1;
	// 該当部分のみ置き換え
	if (!Array.isArray(words) || words.length === 0) {
	  words = await fetchWordsFromServer(selectedPart); // ← userIdを渡さない
	}
  swipeWords = await buildSwipeDeck(mode);
  if (swipeWords.length === 0) {
    Swal.fire({icon:'info', title:(mode==="review"?"今日は復習がありません":"今日は未学習がありません")});
    setSwipeModeVisible(false);
    return;
  }
  swipeIndex = 0; swipeLearned = 0; swipeUnlearned = 0;
  await renderSwipeDeck();
  updateSwipeHUD();
  document.getElementById('swipeExitBtn').onclick = exitSwipeMode;

  // iOSの横スワイプ干渉対策（下の 3) とセット）
  preventIOSBackSwipe();
  enableSwipeBackGuard();
}		
		// 🔸 スワイプ用デッキを組む（未学習のみ + 今日の除外を引く）
// ランダムサンプル用ユーティリティ（Fisher–Yates）
// ランダムに配列をシャッフル（in-place）
// in-place shuffle
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/**
 * 未学習を優先して N 枚でデッキ構築（未学習:reviewRatio[0], 復習:reviewRatio[1]）
 * 足りないときは相互に融通し、それでも足りなければ除外無視で補充
 */
//shuffle はそのまま利用

//既存の buildSwipeDeck を丸ごと置き換え
async function buildSwipeDeck(mode = "unlearned"){
  const userId   = getUserIdFromQuery() || getUserId();
  const excluded = getSwipeExcludedSet(userId);

  const allUnlearned = words.filter(w => !w.status);
  const allLearned   = words.filter(w =>  w.status);

  // 既定は「今日の除外を外す」
  let unlearned = allUnlearned.filter(w => !excluded.has(w.id));
  let learned   = allLearned.filter(w   => !excluded.has(w.id));

  // ★ 復習モードで候補0なら、除外を無視してでも出す（起動できないのを防ぐ）
  if (mode === "review" && learned.length === 0 && allLearned.length > 0) {
    learned = allLearned.slice();
  }

  shuffle(unlearned);
  shuffle(learned);

  if (mode === "unlearned") return shuffle(unlearned.slice(0, 10));
  if (mode === "review")    return shuffle(learned.slice(0, 10));

  return shuffle([
    ...unlearned.slice(0,25),
    ...learned.slice(0,5)
  ]);
}




	// デッキ描画（先頭3枚だけ積む）
// デッキ描画（先頭3枚だけ積む）
async function renderSwipeDeck(){
  // DOMのデッキ要素
  const deckEl = document.getElementById('swipeDeck');
  deckEl.innerHTML = '';

  // swipeWords がまだ用意されていなければ作る
if (!Array.isArray(swipeWords) || swipeWords.length === 0) {
	// 現在選択中のモードでデッキを作る
	swipeWords = await buildSwipeDeck(currentSwipeMode);
	console.log('deck size:', swipeWords.length,
            'unlearned total:', words.filter(w=>!w.status).length,
            'learned total:', words.filter(w=> w.status).length);
}

  // 今の位置から3枚だけ描画
  const show = swipeWords.slice(swipeIndex, Math.min(swipeIndex + 3, swipeWords.length));

  show.forEach((w, idx) => {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.style.zIndex = String(100 - idx);
    card.dataset.index = String(swipeIndex + idx);

    // renderSwipeDeck
	const src = safeSrc(imageUrlForWord(w), { allowDataImage: true });

    card.innerHTML = `
    	  <div class="swipe-badge badge-left">覚えてない</div>
    	  <div class="swipe-badge badge-right">覚えた！</div>
    	  <div class="swipe-word">${esc(w.word)}</div>
    	  <div class="swipe-mean">(${esc(w.meaning)})</div>
    	  <img class="swipe-img" src="${src}" alt="${esc(w.word)}" draggable="false">
    	`;

    // 画像が404の時はデフォルトにフォールバック
    const imgEl = card.querySelector('.swipe-img');
    imgEl.onerror = () => { imgEl.src = '/images/beauty.png'; };

    attachSwipeHandlers(card);
    deckEl.appendChild(card);
  });
}


	// 1枚のカードにドラッグ/タッチ操作を付与
function attachSwipeHandlers(card){
  card.addEventListener('pointerdown', e => {
    e.preventDefault();                 // ← 既定動作(画像ドラッグ等)を抑止
    card.setPointerCapture(e.pointerId);
    swipeDrag = {startX:e.clientX, startY:e.clientY, el:card};
    card.style.transition = 'none';
  });

  card.addEventListener('pointermove', e => {
    if(!swipeDrag || swipeDrag.el!==card) return;
    const dx = e.clientX - swipeDrag.startX;
    const dy = e.clientY - swipeDrag.startY;
    const rot = dx * 0.05;
    card.style.transform = `translate(${dx}px, ${dy}px) rotate(${rot}deg)`;
    const left  = card.querySelector('.badge-left');
    const right = card.querySelector('.badge-right');
    if(dx < -20){ left.style.opacity = Math.min(1, (-dx)/80); right.style.opacity = 0; }
    else if(dx > 20){ right.style.opacity = Math.min(1, (dx)/80); left.style.opacity = 0; }
    else { left.style.opacity = right.style.opacity = 0; }
  });

  card.addEventListener('pointerup',     e => endSwipe(card, e));

  // ← ここを“リセットのみ”に
  card.addEventListener('pointercancel', () => {
    card.style.transition = '.2s ease';
    card.style.transform = 'translate(0,0) rotate(0)';
    card.querySelector('.badge-left').style.opacity  = 0;
    card.querySelector('.badge-right').style.opacity = 0;
    swipeDrag = null;
  });

  // 念のため HTML5 の dragstart も殺す
  card.addEventListener('dragstart', e => e.preventDefault());
}


	function endSwipe(card, e){
	  if(!swipeDrag){ return; }
	  const dx = e.clientX - swipeDrag.startX;
	  swipeDrag = null;

	  // 確定判定
	  if(dx <= -SWIPE_THRESHOLD){
	    // 左：覚えてない
	    decideSwipe(card, 'left');
	  }else if(dx >= SWIPE_THRESHOLD){
	    // 右：覚えた
	    decideSwipe(card, 'right');
	  }else{
	    // 戻す
	    card.style.transition = '.2s ease';
	    card.style.transform = 'translate(0,0) rotate(0)';
	    card.querySelector('.badge-left').style.opacity = 0;
	    card.querySelector('.badge-right').style.opacity = 0;
	  }
	}

	// 反映＆次のカードへ
// 既存の decideSwipe を丸ごと置き換え
// ← これで上書き
async function decideSwipe(card, dir){
  const i = swipeIndex;
  const w = swipeWords[i];
  const isRight = (dir === 'right'); // 右=良い判定

  // 見た目アニメ
  card.style.transition = '.2s ease';
  const off = (isRight ? 600 : -600);
  card.style.transform = `translate(${off}px,-40px) rotate(${off>0?15:-15}deg)`;
  setTimeout(() => card.remove(), 200);

  // “今日のメモ”に保存（DBは onSwipeRightLearned 内だけで反映）
  if (currentSwipeMode === "unlearned") {
    if (isRight) {
      addTodaySet('learned', w.id);
      addToSwipeExcluded(getUserId(), w.id);
      swipeLearned++;
      onSwipeRightLearned(w); // 失敗しても体験は継続
    } else {
      addTodaySet('unlearned', w.id);
      swipeUnlearned++;
    }
  } else { // review
    if (isRight) {
      swipeLearned++;
      addTodaySet('review_ok', w.id);
    } else {
      swipeUnlearned++;
      addTodaySet('review_ng', w.id);
    }
    addToSwipeExcluded(getUserId(), w.id); // 復習でも今日は重複させない
  }

  swipeIndex++;
  updateSwipeHUD();

  // スワイプの定期広告
  if (!user.premium &&
      AD_EVERY_SWIPE > 0 &&
      swipeIndex % AD_EVERY_SWIPE === 0 &&
      swipeIndex < swipeWords.length) {
    watchAdGlobal();
  }

  if (swipeIndex < swipeWords.length) {
    await renderSwipeDeck();
  } else {
    exitSwipeMode(); // 一覧へ戻る（DB更新なし）
  }
}




//既存の updateSwipeHUD を丸ごと置き換え
function updateSwipeHUD(){
  const total = swipeWords.length;
  document.getElementById('swipeCounter').textContent = `${swipeIndex}/${total}`;

  if (currentSwipeMode === "unlearned") {
    // 当日メモ（未学習用）
    const learnedSet   = getTodaySet('learned');
    const unlearnedSet = getTodaySet('unlearned');
    document.getElementById('swipeStats').textContent =
      `覚えた: ${learnedSet.size} / 覚えてない: ${unlearnedSet.size}`;
  } else {
    // セッションカウント（復習用）
    document.getElementById('swipeStats').textContent =
      `OK: ${swipeLearned} / 忘れていた: ${swipeUnlearned}`;
  }
}

// 先頭あたりに
const getCSRFFromCookie = (name='_csrf') => {
  const m = document.cookie.match(new RegExp(`(?:^|; )${name}=([^;]+)`));
  return m ? decodeURIComponent(m[1]) : null;
};

// 置き換え
async function onSwipeRightLearned(word){
  try{
    await apiFetch('/api/learning/update', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ wordId: word.id, status: true, part: selectedPart })
    });
    const w = words.find(x => x.id === word.id);
    if (w) w.status = true;
    addToSwipeExcluded(getUserId(), word.id);
  }catch(e){
    console.warn('学習済み反映失敗', e);
  }
}    
    const SWIPE_TUTOR_KEY = 'swipe_tutorial_shown_v1';

    function showSwipeHowToIfNeeded(){
      if (localStorage.getItem(SWIPE_TUTOR_KEY) === '1') return;
      Swal.fire({
        title: 'スワイプ学習のコツ',
        html: `
          <div style="text-align:left;line-height:1.8">
            <p>・右スワイプ = <b>覚えた！→ 学習済みに反映</b></p>
            <p>・左スワイプ = まだ覚えてない（デッキ後方へ）</p>
            <p>・今日覚えた単語は、<b>その日は再表示されません</b></p>
            <p>・対象は <b>未学習だけ</b>。効率よく覚えよう！</p>
          </div>
        `,
        confirmButtonText: 'OK',
        confirmButtonColor: '#e91e63'
      }).then(()=> localStorage.setItem(SWIPE_TUTOR_KEY,'1'));
    }

document.addEventListener('keydown', (e) => {
  // Esc でモーダル類を閉じる
  if (e.key === 'Escape') {
    const ad = document.getElementById('adModal');
    if (ad?.style.display === 'flex') closeAdModal();

    const vm = document.getElementById('videoModal');
    const vp = document.getElementById('videoPlayer');
    if (vm?.style.display === 'flex') { vm.style.display = 'none'; vp?.pause(); }

    const box = document.getElementById('swipeModeBox');
    if (!box.classList.contains('hidden')) exitSwipeMode();
    return;
  }

  // スワイプ中のみ ← / → を効かせる
  const box = document.getElementById('swipeModeBox');
  if (box.classList.contains('hidden')) return;

  const top = document.querySelector(`.swipe-card[data-index="${swipeIndex}"]`);
  if (!top) return;

  if (e.key === 'ArrowRight') { e.preventDefault(); decideSwipe(top, 'right'); }
  if (e.key === 'ArrowLeft')  { e.preventDefault(); decideSwipe(top, 'left');  }
});
	</script>
　　<!-- カスタム広告・プレミアムモーダル -->
<div id="adModal" role="dialog" aria-modal="true" class="modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); z-index:1000; justify-content:center; align-items:center;">
  <div class="modal-content" style="background:white; padding:30px; border-radius:10px; max-width:90%; text-align:center;">
    <h2 style="color:#e91e63;"><i class="fas fa-info-circle"></i> このパートは広告視聴が必要です</h2>
    <p>広告を見ると5枚だけ美女で英単語を表現するボタンが開放されます。<br>有料プランなら無制限で開放されます。</p>
    <div class="modal-buttons" style="margin-top:20px;">
      <button id="watchAdBtn" class="btn btn-primary" onclick="handleAdAccept()">広告を見る</button>
      <button id="closeModalBtn" class="btn btn-secondary" onclick="closeAdModal()">やめる</button>
      <button id="upgradeBtn" class="btn btn-premium" onclick="location.href='/premium.html'">🎀 プレミアムで無制限開放 (月額300円)🎀</button>
    </div>
  </div>
</div>
	</body>
	</html>
