<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>美女単 - 新規登録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body{margin:0;padding:0;background:linear-gradient(135deg,#f8e8f0,#f0f8ff);
      font-family:Arial,Helvetica,sans-serif;display:flex;justify-content:center;
      align-items:center;min-height:100vh;flex-direction:column;text-align:center}
    h2{color:#e91e63;font-size:2rem;margin-bottom:24px}
    form{display:flex;flex-direction:column;gap:14px;width:min(320px,90vw)}
    input{padding:12px;border:1px solid #ccc;border-radius:10px;font-size:1rem}
    button{font-size:1.1rem;padding:12px 18px;background:#ff4081;border:none;
      border-radius:30px;color:#fff;cursor:pointer;box-shadow:0 4px 6px rgba(0,0,0,.1);
      transition:background .25s}
    button:hover{background:#f50057}
    .links{margin-top:16px}
    .links a{color:#e91e63;text-decoration:none}
    .links a:hover{text-decoration:underline}
    small.helper{color:#666}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>
<body>
  <h2>新規ユーザー登録</h2>

  <form id="registerForm" onsubmit="handleRegister(event);return false;">
    <!-- 画面には出さない。送信時に email をそのまま name に入れる -->
    <input id="regName" name="name" type="hidden" />
    <input id="regEmail" name="email" type="email" autocomplete="email"
           required placeholder="メールアドレス" inputmode="email" />
    <input id="regPass" name="password" type="password" autocomplete="new-password"
           required minlength="6" placeholder="パスワード（6文字以上）" />
    <button>新規登録</button>
    <small class="helper">※ ユーザー名はメールアドレスを使用します</small>
  </form>

  <div class="links">
    <a href="login.html">ログイン画面に戻る</a>
  </div>

<script>
  // --- 共通 fetch（CSRF 自動付与） ---
  const apiFetch = (path, opts = {}) => {
    const method = (opts.method || 'GET').toUpperCase();
    const needsCSRF = !['GET','HEAD','OPTIONS'].includes(method);

    const pickCSRFFromPageOrCookie = () => {
      const meta = document.querySelector('meta[name="csrf-token"]')?.content;
      if (meta) return { header:'X-CSRF-Token', token: meta };
      const ck = document.cookie || '';
      const m1 = ck.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/);
      if (m1) return { header:'X-CSRF-TOKEN', token: decodeURIComponent(m1[1]) };
      const m2 = ck.match(/(?:^|;\s*)_csrf=([^;]+)/);
      if (m2) return { header:'X-CSRF-Token', token: decodeURIComponent(m2[1]) };
      return null;
    };

    const headers = new Headers({ Accept: 'application/json', ...(opts.headers||{}) });
    if (needsCSRF && !headers.has('X-CSRF-Token') && !headers.has('X-CSRF-TOKEN')) {
      const c = pickCSRFFromPageOrCookie();
      if (c) headers.set(c.header, c.token);
    }
    return fetch(path, { credentials: 'include', ...opts, headers });
  };

  // -------- util --------
  const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

  // id 取り出し
  const parseIdFromJson = j => {
    const c = [j?.id,j?.userId,j?.user_id,j?.user?.id,j?.data?.id,j?.data?.user?.id];
    for (const v of c) if (v!=null && String(v) !== '') return String(v);
    return null;
  };
  const parseIdFromText = t => {
    if (!t) return null;
    let m = t.match(/["']?(?:userId|user_id|id)["']?\s*[:=]\s*["']?(\d{1,})["']?/i);
    if (m) return m[1];
    m = t.match(/\/(?:api\/)?(?:user|users)\/(\d{1,})(?:\D|$)/i);
    if (m) return m[1];
    return null;
  };

  // /api/me の軽ポーリング
  const pollMe = async (retry=8, interval=300) => {
    const urls = ['/api/me','/user/me','/api/user/me','/me'];
    for (let r=0;r<retry;r++){
      for (const u of urls){
        try{
          const res = await apiFetch(u, {cache:'no-store'});
          const ct  = (res.headers.get('content-type')||'').toLowerCase();
          if (!res.ok || !ct.includes('application/json')) continue;
          const me = await res.json();
          const id = parseIdFromJson(me);
          if (id) return me;
        }catch{}
      }
      await sleep(interval);
    }
    return null;
  };

  // local-part を安全に
  const localPart = (email='') => {
    const lp = String(email).split('@')[0] || 'user';
    return lp.normalize('NFKD')
             .replace(/[^\w.-]/g,'_')
             .replace(/^_+|_+$/g,'')
             .slice(0, 30) || 'user';
  };

  // 自動ログイン（2系統）
  async function autoLogin(email, password){
    try{
      const r = await apiFetch('/api/auth/login', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ email, password })
      });
      if (r.ok) return true;
    }catch{}
    try{
      const r = await apiFetch('/login', {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body: new URLSearchParams({ email, password })
      });
      if (r.ok || r.redirected) return true;
    }catch{}
    return false;
  }

  /* ---- クライアント・ランダムソルト & ハッシュ ---- */
  const CLIENT_SALT_KEY = 'client_salt_v1';
  function getClientSalt(){
    let s = localStorage.getItem(CLIENT_SALT_KEY);
    if (!s){
      const buf = new Uint8Array(8);
      crypto.getRandomValues(buf);
      s = Array.from(buf).map(b => b.toString(16).padStart(2,'0')).join('');
      localStorage.setItem(CLIENT_SALT_KEY, s);
    }
    return s;
  }
  async function sha256Base64Url(str){
    const enc = new TextEncoder().encode(str);
    const buf = await crypto.subtle.digest('SHA-256', enc);
    const bytes = new Uint8Array(buf);
    let bin = '';
    for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }

  /* -------------------- 登録処理 -------------------- */
  async function handleRegister(e){
    e.preventDefault();
    const btn = e.submitter || document.querySelector('#registerForm button');
    btn.disabled = true;

    const email = document.getElementById('regEmail').value.trim();
    const password = document.getElementById('regPass').value;
    const name = localPart(email);                 // 表示名に local-part を使う

    // 先に表示名を保存（user.html の“ゲストさん”回避用フォールバック）
    localStorage.setItem('displayName', name);

    try{
      // 登録
      const r = await apiFetch('/api/auth/register', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ name, email, password })
      });
      if (!(r.status===200 || r.status===201 || r.status===204)){
        const msg = r.status===409 ? 'このメールは既に使われています' : '登録に失敗しました';
        Swal.fire({icon:'error', text:msg}); btn.disabled=false; return false;
      }

      // 自動ログイン（サーバセッションを作る）
      await autoLogin(email, password);

      // セッション確立を /api/me で**確実に**確認して保存
      // （ここができていないと test や weekly でログイン画面に飛ぶ）
      let me = await pollMe(12, 300);          // 最大 ~3.6s 待機
      if (!me){
        // レスポンスから拾えるなら拾う
        try{ me = await r.clone().json(); }catch{}
      }

      // userId / name を最終確定
      let userId = parseIdFromJson(me) || null;
      let finalName = me?.name || me?.username || (me?.email ? localPart(me.email) : name);

      if (userId) localStorage.setItem('userId', String(userId));
      localStorage.setItem('displayName', finalName);
      localStorage.setItem('authTs', String(Date.now()));   // 直近ログイン印

      // フロント専用の匿名ID（端末ソルト込み）
      try{
        const basis = userId || email || crypto.randomUUID();
        const clientUserId = await sha256Base64Url(String(basis) + '|' + getClientSalt());
        localStorage.setItem('clientUserId', clientUserId);
      }catch{}

      // 遷移（userId が未確定でも一応進める）
      const dest = userId ? `/user.html?userId=${encodeURIComponent(userId)}` : '/user.html';
      Swal.fire({icon:'success', text:'登録できました！'}).then(()=> location.assign(dest));
    }catch(err){
      console.error(err);
      Swal.fire({icon:'error', text:'通信エラーが発生しました'});
    }finally{
      btn.disabled = false;
    }
    return false;
  }
</script>
</body>
</html>
