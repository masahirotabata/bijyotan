<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>美女単 - 新規登録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body{margin:0;padding:0;background:linear-gradient(135deg,#f8e8f0,#f0f8ff);
      font-family:Arial,Helvetica,sans-serif;display:flex;justify-content:center;
      align-items:center;min-height:100vh;flex-direction:column;text-align:center}
    h2{color:#e91e63;font-size:2rem;margin-bottom:24px}
    form{display:flex;flex-direction:column;gap:14px;width:min(320px,90vw)}
    input{padding:12px;border:1px solid #ccc;border-radius:10px;font-size:1rem}
    button{font-size:1.1rem;padding:12px 18px;background:#ff4081;border:none;
      border-radius:30px;color:#fff;cursor:pointer;box-shadow:0 4px 6px rgba(0,0,0,.1);
      transition:background .25s}
    button:hover{background:#f50057}
    .links{margin-top:16px}
    .links a{color:#e91e63;text-decoration:none}
    .links a:hover{text-decoration:underline}
    small.helper{color:#666}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
</head>
<body>
  <h2>新規ユーザー登録</h2>

  <form id="registerForm" onsubmit="handleRegister(event);return false;">
    <!-- 画面には出さない。送信時に email をそのまま name に入れる -->
    <input id="regName" name="name" type="hidden" />
    <input id="regEmail" name="email" type="email" autocomplete="email"
           required placeholder="メールアドレス" inputmode="email" />
    <input id="regPass" name="password" type="password" autocomplete="new-password"
           required minlength="6" placeholder="パスワード（6文字以上）" />
    <button>新規登録</button>
    <small class="helper">※ ユーザー名はメールアドレスを使用します</small>
  </form>

  <div class="links">
    <a href="login.html">ログイン画面に戻る</a>
  </div>

<script>
/* ================= 共通ユーティリティ（CSRF付き fetch） ================= */
const apiFetch = (path, opts = {}) => {
  const method = (opts.method || 'GET').toUpperCase();
  const needsCSRF = !['GET','HEAD','OPTIONS'].includes(method);

  const pickCSRFFromPageOrCookie = () => {
    const meta = document.querySelector('meta[name="csrf-token"]')?.content;
    if (meta) return { header: 'X-CSRF-Token', token: meta };
    const ck = document.cookie || '';
    const m1 = ck.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/);
    if (m1) return { header: 'X-CSRF-TOKEN', token: decodeURIComponent(m1[1]) };
    const m2 = ck.match(/(?:^|;\s*)_csrf=([^;]+)/);
    if (m2) return { header: 'X-CSRF-Token', token: decodeURIComponent(m2[1]) };
    return null;
  };

  const headers = new Headers({ Accept: 'application/json', ...(opts.headers||{}) });
  if (needsCSRF && !headers.has('X-CSRF-Token') && !headers.has('X-CSRF-TOKEN')) {
    const c = pickCSRFFromPageOrCookie();
    if (c) headers.set(c.header, c.token);
  }
  return fetch(path, { credentials: 'include', ...opts, headers });
};

/* ================== userId 取得のための総当たりヘルパ =================== */
const parseIdFromJson = (j) => {
  const c = [j?.id, j?.userId, j?.user_id, j?.user?.id, j?.data?.id, j?.data?.user?.id,
             j?.result?.id, j?.payload?.id];
  for (const v of c) if (v != null && String(v) !== '') return String(v);
  return null;
};
const parseIdFromText = (t) => {
  if (!t) return null;
  let m = t.match(/["']?(?:userId|user_id|id)["']?\s*[:=]\s*["']?(\d{1,})["']?/i);
  if (m) return m[1];
  m = t.match(/\/(?:api\/)?(?:user|users)\/(\d{1,})(?:\D|$)/i);
  if (m) return m[1];
  return null;
};
const getIdFromLocationHeader = (res) => {
  const loc = res.headers.get('Location') || res.headers.get('location');
  return loc ? parseIdFromText(String(loc)) : null;
};
const pollMeEndpoints = async (retry=5, intervalMs=300) => {
  const urls = ['/api/me','/user/me','/api/user/me','/api/v1/me','/me','/auth/me'];
  for (let r=0;r<retry;r++){
    for (const u of urls){
      try{
        const res = await fetch(u, { credentials:'include', cache:'no-store' });
        const ct = (res.headers.get('content-type')||'').toLowerCase();
        if (!res.ok || !ct.includes('application/json')) continue;
        const id = parseIdFromJson(await res.json());
        if (id) return id;
      }catch{}
    }
    await new Promise(s=>setTimeout(s, intervalMs));
  }
  return null;
};

/* ======================= メール→ユーザー名方針 =========================
   そのままメールを name に使う。もし表示名でメール露出を避けたい場合は
   下の return email.split('@')[0]; に差し替え。
======================================================================= */
// これに差し替え
function deriveNameFromEmail(email){
  const s = String(email || '').trim();
  const [local = ''] = s.split('@');

  // +タグを除去（foo+tag → foo）
  let name = local.replace(/\+.*/, '');

  // 見た目の安定化：全角→半角などを正規化し、許可文字だけ残す
  name = name.normalize('NFKC')
             .replace(/[^\p{L}\p{N}._-]+/gu, ''); // 文字/数字/._- 以外を削除

  // 長すぎる表示名はカット
  if (name.length > 24) name = name.slice(0, 24);

  // 何も残らなければフォールバック
  return name || 'ユーザー';
}

/* ============================ メイン処理 ============================== */
async function handleRegister(e){
  e.preventDefault();
  const btn = e.submitter || document.querySelector('#registerForm button');
  btn.disabled = true;

  const email = document.getElementById('regEmail').value.trim();
  const password = document.getElementById('regPass').value;
  document.getElementById('regName').value = deriveNameFromEmail(email); // ← ここが肝

  if (!email || !password){
    Swal.fire({icon:'warning', text:'メールとパスワードを入力してください'}); btn.disabled=false; return false;
  }

  try{
    // 1) ユーザー作成
    const res = await apiFetch('/api/auth/register', {
      method:'POST',
      headers:{ 'Content-Type':'application/json' },
      body: JSON.stringify({ name: deriveNameFromEmail(email), email, password })
    });

    if (![200,201,204].includes(res.status)){
      const msg = res.status === 409 ? 'このメールは既に使われています' : '登録に失敗しました';
      Swal.fire({icon:'error', text: msg}); btn.disabled=false; return false;
    }

    // 2) できれば userId を即回収
    let userId = null;
    try { userId = parseIdFromJson(await res.clone().json()); } catch {}
    if (!userId) userId = getIdFromLocationHeader(res);
    if (!userId) { try { userId = parseIdFromText(await res.clone().text()); } catch {} }

    // 3) /api/me でログイン済みか確認（サーバが自動ログインしてくれる構成ならここで取れる）
    if (!userId) userId = await pollMeEndpoints();

    // 4) 未ログインなら自動ログインを試行 → もう一度 /api/me
    if (!userId){
      // CSRF 付けて /login
      const headers = new Headers({ 'Content-Type':'application/x-www-form-urlencoded' });
      // 既存の apiFetch と同じCSRF抽出
      const ck = document.cookie || '';
      const m1 = ck.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/);
      const m2 = ck.match(/(?:^|;\s*)_csrf=([^;]+)/);
      if (m1) headers.set('X-CSRF-TOKEN', decodeURIComponent(m1[1]));
      else if (m2) headers.set('X-CSRF-Token', decodeURIComponent(m2[1]));

      await fetch('/login', {
        method:'POST',
        headers,
        credentials:'include',
        redirect:'manual',
        body: new URLSearchParams({ email, password })
      }).catch(()=>{});
      userId = await pollMeEndpoints();
    }

    if (userId) localStorage.setItem('userId', String(userId));

    const dest = userId ? `/user.html?userId=${encodeURIComponent(userId)}` : '/user.html';
    const go = () => location.assign(dest);
    if (window.Swal) await Swal.fire({icon:'success', text:'登録できました！'}).then(go);
    else { alert('登録できました！'); go(); }

  }catch(err){
    console.error(err);
    Swal.fire({icon:'error', text:'通信エラーが発生しました。時間をおいてお試しください。'});
  }finally{
    btn.disabled = false;
  }

  return false;
}
</script>
</body>
</html>
