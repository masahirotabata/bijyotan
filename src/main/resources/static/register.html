<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ユーザー登録</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <!-- Rails なら meta[name="csrf-token"] が入っている想定 -->
  <style>
    body{font-family:sans-serif;background:#f9f9f9;margin:0;padding:24px;}
    .wrap{max-width:480px;margin:0 auto;background:#fff;border:1px solid #eee;border-radius:12px;padding:18px 16px;box-shadow:0 6px 18px rgba(0,0,0,.05);}
    h1{color:#e91e63;font-size:1.25rem;margin:0 0 12px;}
    label{display:block;font-weight:600;margin:12px 0 6px;}
    input{width:100%;padding:10px;border:1px solid #ccc;border-radius:8px;font-size:1rem;}
    button{margin-top:14px;width:100%;padding:12px;border:none;border-radius:9999px;background:#e91e63;color:#fff;font-size:1rem;cursor:pointer;}
    button:hover{background:#d81b60;}
    .tip{font-size:.85rem;color:#666;margin-top:10px;line-height:1.6;}
    .small{font-size:.8rem;color:#999;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>ユーザー登録</h1>

    <form id="regForm">
      <label for="username">表示名（任意）</label>
      <input id="username" name="username" placeholder="例: Taro" />

      <label for="email">メール（任意）</label>
      <input id="email" name="email" type="email" placeholder="例: you@example.com" />

      <label for="userId">ユーザーID（任意）</label>
      <input id="userId" name="userId" placeholder="例: your-id" />

      <button type="submit">登録する</button>
      <p class="tip">
        入力したユーザーIDは<span style="font-weight:700">その場でSHA-256にハッシュ化</span>してサーバへ送ります。<br>
        URLやDBにはハッシュ値のみが保存されます。
      </p>
      <p class="small">※ 強固な秘匿が必要な場合、サーバ側で pepper を加えた再ハッシュをご利用ください。</p>
    </form>
  </div>

<script>
/** 共通fetch（あなたの user.html と同等のCSRF対応） */
const apiFetch = (path, opts = {}) => {
  const method = (opts.method || 'GET').toUpperCase();
  const needsCSRF = !['GET','HEAD','OPTIONS'].includes(method);

  const pickCSRFFromPageOrCookie = () => {
    const meta = document.querySelector('meta[name="csrf-token"]')?.content;
    if (meta) return { header: 'X-CSRF-Token', token: meta };
    const m1 = document.cookie.match(/(?:^|;\s*)XSRF-TOKEN=([^;]+)/); // Spring
    if (m1) return { header: 'X-CSRF-TOKEN', token: decodeURIComponent(m1[1]) };
    const m2 = document.cookie.match(/(?:^|;\s*)_csrf=([^;]+)/);      // 旧
    if (m2) return { header: 'X-CSRF-Token', token: decodeURIComponent(m2[1]) };
    return null;
  };

  const headers = new Headers({ Accept: 'application/json', ...(opts.headers || {}) });
  if (needsCSRF && !headers.has('X-CSRF-Token') && !headers.has('X-CSRF-TOKEN')) {
    const c = pickCSRFFromPageOrCookie();
    if (c) headers.set(c.header, c.token);
  }
  return fetch(path, { credentials: 'include', ...opts, headers });
};

/** JSON専用fetch（エラーを例外化） */
async function fetchJSON(url, opts = {}) {
  const res = await apiFetch(url, opts);
  const ct = (res.headers.get('content-type') || '').toLowerCase();
  if (res.status === 204) return null;
  if (!ct.includes('application/json')) {
    const err = new Error('NON_JSON'); err.status = res.status; throw err;
  }
  if (!res.ok) {
    const body = await res.json().catch(()=> ({}));
    const err = new Error(body.message || `HTTP ${res.status}`);
    err.status = res.status; err.body = body; throw err;
  }
  return res.json();
}

/** 文字列 → SHA-256 → Base64URL */
async function sha256Base64Url(str) {
  const enc = new TextEncoder().encode(str);
  const buf = await crypto.subtle.digest('SHA-256', enc);
  const bytes = new Uint8Array(buf);
  let bin = '';
  for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

/** 登録処理 */
document.getElementById('regForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  const username = document.getElementById('username').value.trim();
  const email    = document.getElementById('email').value.trim();
  const rawId    = document.getElementById('userId').value.trim();

  // 入力が空でも動くように、ハッシュの元は以下の優先順で作る
  const rawForHash = rawId || email || (username ? `u:${username}` : crypto.randomUUID());
  const hashedUserId = await sha256Base64Url(rawForHash);

  const payload = {
    username: username || null,
    email: email || null,
    // サーバ側のカラム例: hashed_user_id
    hashedUserId
  };

  // 第一候補とフォールバック
  const candidates = [
    ['/api/register', payload],
    ['/user/register', payload],
  ];

  let ok = false, lastErr = null, data = null;
  for (const [url, body] of candidates) {
    try {
      data = await fetchJSON(url, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify(body)
      });
      ok = true; break;
    } catch (err) {
      lastErr = err; // 次の候補へ
    }
  }
  if (!ok) {
    alert(`登録に失敗しました: ${lastErr?.message || 'network error'}`);
    return;
  }

  // 以降はハッシュIDのみをクライアントで保持・使用
  localStorage.setItem('userId', hashedUserId);

  // user.html へ。URLにもハッシュIDを付けたい場合:
  location.assign(`/user.html?userId=${encodeURIComponent(hashedUserId)}`);
});
</script>
</body>
</html>
